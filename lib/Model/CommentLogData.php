<?php
/**
 * CommentLogData
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  FastComments\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * fastcomments
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * Contact: support@fastcomments.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace FastComments\Client\Model;

use \ArrayAccess;
use \FastComments\Client\ObjectSerializer;

/**
 * CommentLogData Class Doc Comment
 *
 * @category Class
 * @package  FastComments\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class CommentLogData implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'CommentLogData';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'clear_content' => 'bool',
        'is_deleted_user' => 'bool',
        'phrase' => 'string',
        'bad_word' => 'string',
        'word' => 'string',
        'locale' => 'string',
        'tenant_badge_id' => 'string',
        'badge_id' => 'string',
        'was_logged_in' => 'bool',
        'found_user' => 'bool',
        'verified' => 'bool',
        'engine' => 'string',
        'engine_response' => 'string',
        'engine_tokens' => 'float',
        'trust_factor' => 'float',
        'rule' => '\FastComments\Client\Model\SpamRule',
        'user_id' => 'string',
        'subscribers' => 'float',
        'notification_count' => 'float',
        'votes_before' => 'float',
        'votes_up_before' => 'float',
        'votes_down_before' => 'float',
        'votes_after' => 'float',
        'votes_up_after' => 'float',
        'votes_down_after' => 'float',
        'repeat_action' => '\FastComments\Client\Model\RepeatCommentHandlingAction',
        'reason' => '\FastComments\Client\Model\RepeatCommentCheckIgnoredReason',
        'other_data' => 'mixed',
        'spam_before' => 'bool',
        'spam_after' => 'bool',
        'permanent_flag' => 'string',
        'approved_before' => 'bool',
        'approved_after' => 'bool',
        'reviewed_before' => 'bool',
        'reviewed_after' => 'bool',
        'text_before' => 'string',
        'text_after' => 'string',
        'expire_before' => '\DateTime',
        'expire_after' => '\DateTime',
        'flag_count_before' => 'float',
        'trust_factor_before' => 'float',
        'trust_factor_after' => 'float',
        'referenced_comment_id' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'clear_content' => null,
        'is_deleted_user' => null,
        'phrase' => null,
        'bad_word' => null,
        'word' => null,
        'locale' => null,
        'tenant_badge_id' => null,
        'badge_id' => null,
        'was_logged_in' => null,
        'found_user' => null,
        'verified' => null,
        'engine' => null,
        'engine_response' => null,
        'engine_tokens' => 'double',
        'trust_factor' => 'double',
        'rule' => null,
        'user_id' => null,
        'subscribers' => 'double',
        'notification_count' => 'double',
        'votes_before' => 'double',
        'votes_up_before' => 'double',
        'votes_down_before' => 'double',
        'votes_after' => 'double',
        'votes_up_after' => 'double',
        'votes_down_after' => 'double',
        'repeat_action' => null,
        'reason' => null,
        'other_data' => null,
        'spam_before' => null,
        'spam_after' => null,
        'permanent_flag' => null,
        'approved_before' => null,
        'approved_after' => null,
        'reviewed_before' => null,
        'reviewed_after' => null,
        'text_before' => null,
        'text_after' => null,
        'expire_before' => 'date-time',
        'expire_after' => 'date-time',
        'flag_count_before' => 'double',
        'trust_factor_before' => 'double',
        'trust_factor_after' => 'double',
        'referenced_comment_id' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'clear_content' => false,
        'is_deleted_user' => false,
        'phrase' => false,
        'bad_word' => false,
        'word' => false,
        'locale' => false,
        'tenant_badge_id' => false,
        'badge_id' => false,
        'was_logged_in' => false,
        'found_user' => false,
        'verified' => false,
        'engine' => false,
        'engine_response' => false,
        'engine_tokens' => false,
        'trust_factor' => false,
        'rule' => false,
        'user_id' => false,
        'subscribers' => false,
        'notification_count' => false,
        'votes_before' => true,
        'votes_up_before' => true,
        'votes_down_before' => true,
        'votes_after' => true,
        'votes_up_after' => true,
        'votes_down_after' => true,
        'repeat_action' => false,
        'reason' => false,
        'other_data' => true,
        'spam_before' => false,
        'spam_after' => false,
        'permanent_flag' => false,
        'approved_before' => false,
        'approved_after' => false,
        'reviewed_before' => false,
        'reviewed_after' => false,
        'text_before' => false,
        'text_after' => false,
        'expire_before' => true,
        'expire_after' => true,
        'flag_count_before' => true,
        'trust_factor_before' => false,
        'trust_factor_after' => false,
        'referenced_comment_id' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'clear_content' => 'clearContent',
        'is_deleted_user' => 'isDeletedUser',
        'phrase' => 'phrase',
        'bad_word' => 'badWord',
        'word' => 'word',
        'locale' => 'locale',
        'tenant_badge_id' => 'tenantBadgeId',
        'badge_id' => 'badgeId',
        'was_logged_in' => 'wasLoggedIn',
        'found_user' => 'foundUser',
        'verified' => 'verified',
        'engine' => 'engine',
        'engine_response' => 'engineResponse',
        'engine_tokens' => 'engineTokens',
        'trust_factor' => 'trustFactor',
        'rule' => 'rule',
        'user_id' => 'userId',
        'subscribers' => 'subscribers',
        'notification_count' => 'notificationCount',
        'votes_before' => 'votesBefore',
        'votes_up_before' => 'votesUpBefore',
        'votes_down_before' => 'votesDownBefore',
        'votes_after' => 'votesAfter',
        'votes_up_after' => 'votesUpAfter',
        'votes_down_after' => 'votesDownAfter',
        'repeat_action' => 'repeatAction',
        'reason' => 'reason',
        'other_data' => 'otherData',
        'spam_before' => 'spamBefore',
        'spam_after' => 'spamAfter',
        'permanent_flag' => 'permanentFlag',
        'approved_before' => 'approvedBefore',
        'approved_after' => 'approvedAfter',
        'reviewed_before' => 'reviewedBefore',
        'reviewed_after' => 'reviewedAfter',
        'text_before' => 'textBefore',
        'text_after' => 'textAfter',
        'expire_before' => 'expireBefore',
        'expire_after' => 'expireAfter',
        'flag_count_before' => 'flagCountBefore',
        'trust_factor_before' => 'trustFactorBefore',
        'trust_factor_after' => 'trustFactorAfter',
        'referenced_comment_id' => 'referencedCommentId'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'clear_content' => 'setClearContent',
        'is_deleted_user' => 'setIsDeletedUser',
        'phrase' => 'setPhrase',
        'bad_word' => 'setBadWord',
        'word' => 'setWord',
        'locale' => 'setLocale',
        'tenant_badge_id' => 'setTenantBadgeId',
        'badge_id' => 'setBadgeId',
        'was_logged_in' => 'setWasLoggedIn',
        'found_user' => 'setFoundUser',
        'verified' => 'setVerified',
        'engine' => 'setEngine',
        'engine_response' => 'setEngineResponse',
        'engine_tokens' => 'setEngineTokens',
        'trust_factor' => 'setTrustFactor',
        'rule' => 'setRule',
        'user_id' => 'setUserId',
        'subscribers' => 'setSubscribers',
        'notification_count' => 'setNotificationCount',
        'votes_before' => 'setVotesBefore',
        'votes_up_before' => 'setVotesUpBefore',
        'votes_down_before' => 'setVotesDownBefore',
        'votes_after' => 'setVotesAfter',
        'votes_up_after' => 'setVotesUpAfter',
        'votes_down_after' => 'setVotesDownAfter',
        'repeat_action' => 'setRepeatAction',
        'reason' => 'setReason',
        'other_data' => 'setOtherData',
        'spam_before' => 'setSpamBefore',
        'spam_after' => 'setSpamAfter',
        'permanent_flag' => 'setPermanentFlag',
        'approved_before' => 'setApprovedBefore',
        'approved_after' => 'setApprovedAfter',
        'reviewed_before' => 'setReviewedBefore',
        'reviewed_after' => 'setReviewedAfter',
        'text_before' => 'setTextBefore',
        'text_after' => 'setTextAfter',
        'expire_before' => 'setExpireBefore',
        'expire_after' => 'setExpireAfter',
        'flag_count_before' => 'setFlagCountBefore',
        'trust_factor_before' => 'setTrustFactorBefore',
        'trust_factor_after' => 'setTrustFactorAfter',
        'referenced_comment_id' => 'setReferencedCommentId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'clear_content' => 'getClearContent',
        'is_deleted_user' => 'getIsDeletedUser',
        'phrase' => 'getPhrase',
        'bad_word' => 'getBadWord',
        'word' => 'getWord',
        'locale' => 'getLocale',
        'tenant_badge_id' => 'getTenantBadgeId',
        'badge_id' => 'getBadgeId',
        'was_logged_in' => 'getWasLoggedIn',
        'found_user' => 'getFoundUser',
        'verified' => 'getVerified',
        'engine' => 'getEngine',
        'engine_response' => 'getEngineResponse',
        'engine_tokens' => 'getEngineTokens',
        'trust_factor' => 'getTrustFactor',
        'rule' => 'getRule',
        'user_id' => 'getUserId',
        'subscribers' => 'getSubscribers',
        'notification_count' => 'getNotificationCount',
        'votes_before' => 'getVotesBefore',
        'votes_up_before' => 'getVotesUpBefore',
        'votes_down_before' => 'getVotesDownBefore',
        'votes_after' => 'getVotesAfter',
        'votes_up_after' => 'getVotesUpAfter',
        'votes_down_after' => 'getVotesDownAfter',
        'repeat_action' => 'getRepeatAction',
        'reason' => 'getReason',
        'other_data' => 'getOtherData',
        'spam_before' => 'getSpamBefore',
        'spam_after' => 'getSpamAfter',
        'permanent_flag' => 'getPermanentFlag',
        'approved_before' => 'getApprovedBefore',
        'approved_after' => 'getApprovedAfter',
        'reviewed_before' => 'getReviewedBefore',
        'reviewed_after' => 'getReviewedAfter',
        'text_before' => 'getTextBefore',
        'text_after' => 'getTextAfter',
        'expire_before' => 'getExpireBefore',
        'expire_after' => 'getExpireAfter',
        'flag_count_before' => 'getFlagCountBefore',
        'trust_factor_before' => 'getTrustFactorBefore',
        'trust_factor_after' => 'getTrustFactorAfter',
        'referenced_comment_id' => 'getReferencedCommentId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const PERMANENT_FLAG_PERMANENT = 'permanent';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPermanentFlagAllowableValues()
    {
        return [
            self::PERMANENT_FLAG_PERMANENT,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('clear_content', $data ?? [], null);
        $this->setIfExists('is_deleted_user', $data ?? [], null);
        $this->setIfExists('phrase', $data ?? [], null);
        $this->setIfExists('bad_word', $data ?? [], null);
        $this->setIfExists('word', $data ?? [], null);
        $this->setIfExists('locale', $data ?? [], null);
        $this->setIfExists('tenant_badge_id', $data ?? [], null);
        $this->setIfExists('badge_id', $data ?? [], null);
        $this->setIfExists('was_logged_in', $data ?? [], null);
        $this->setIfExists('found_user', $data ?? [], null);
        $this->setIfExists('verified', $data ?? [], null);
        $this->setIfExists('engine', $data ?? [], null);
        $this->setIfExists('engine_response', $data ?? [], null);
        $this->setIfExists('engine_tokens', $data ?? [], null);
        $this->setIfExists('trust_factor', $data ?? [], null);
        $this->setIfExists('rule', $data ?? [], null);
        $this->setIfExists('user_id', $data ?? [], null);
        $this->setIfExists('subscribers', $data ?? [], null);
        $this->setIfExists('notification_count', $data ?? [], null);
        $this->setIfExists('votes_before', $data ?? [], null);
        $this->setIfExists('votes_up_before', $data ?? [], null);
        $this->setIfExists('votes_down_before', $data ?? [], null);
        $this->setIfExists('votes_after', $data ?? [], null);
        $this->setIfExists('votes_up_after', $data ?? [], null);
        $this->setIfExists('votes_down_after', $data ?? [], null);
        $this->setIfExists('repeat_action', $data ?? [], null);
        $this->setIfExists('reason', $data ?? [], null);
        $this->setIfExists('other_data', $data ?? [], null);
        $this->setIfExists('spam_before', $data ?? [], null);
        $this->setIfExists('spam_after', $data ?? [], null);
        $this->setIfExists('permanent_flag', $data ?? [], null);
        $this->setIfExists('approved_before', $data ?? [], null);
        $this->setIfExists('approved_after', $data ?? [], null);
        $this->setIfExists('reviewed_before', $data ?? [], null);
        $this->setIfExists('reviewed_after', $data ?? [], null);
        $this->setIfExists('text_before', $data ?? [], null);
        $this->setIfExists('text_after', $data ?? [], null);
        $this->setIfExists('expire_before', $data ?? [], null);
        $this->setIfExists('expire_after', $data ?? [], null);
        $this->setIfExists('flag_count_before', $data ?? [], null);
        $this->setIfExists('trust_factor_before', $data ?? [], null);
        $this->setIfExists('trust_factor_after', $data ?? [], null);
        $this->setIfExists('referenced_comment_id', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getPermanentFlagAllowableValues();
        if (!is_null($this->container['permanent_flag']) && !in_array($this->container['permanent_flag'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'permanent_flag', must be one of '%s'",
                $this->container['permanent_flag'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets clear_content
     *
     * @return bool|null
     */
    public function getClearContent()
    {
        return $this->container['clear_content'];
    }

    /**
     * Sets clear_content
     *
     * @param bool|null $clear_content clear_content
     *
     * @return self
     */
    public function setClearContent($clear_content)
    {
        if (is_null($clear_content)) {
            throw new \InvalidArgumentException('non-nullable clear_content cannot be null');
        }
        $this->container['clear_content'] = $clear_content;

        return $this;
    }

    /**
     * Gets is_deleted_user
     *
     * @return bool|null
     */
    public function getIsDeletedUser()
    {
        return $this->container['is_deleted_user'];
    }

    /**
     * Sets is_deleted_user
     *
     * @param bool|null $is_deleted_user is_deleted_user
     *
     * @return self
     */
    public function setIsDeletedUser($is_deleted_user)
    {
        if (is_null($is_deleted_user)) {
            throw new \InvalidArgumentException('non-nullable is_deleted_user cannot be null');
        }
        $this->container['is_deleted_user'] = $is_deleted_user;

        return $this;
    }

    /**
     * Gets phrase
     *
     * @return string|null
     */
    public function getPhrase()
    {
        return $this->container['phrase'];
    }

    /**
     * Sets phrase
     *
     * @param string|null $phrase phrase
     *
     * @return self
     */
    public function setPhrase($phrase)
    {
        if (is_null($phrase)) {
            throw new \InvalidArgumentException('non-nullable phrase cannot be null');
        }
        $this->container['phrase'] = $phrase;

        return $this;
    }

    /**
     * Gets bad_word
     *
     * @return string|null
     */
    public function getBadWord()
    {
        return $this->container['bad_word'];
    }

    /**
     * Sets bad_word
     *
     * @param string|null $bad_word bad_word
     *
     * @return self
     */
    public function setBadWord($bad_word)
    {
        if (is_null($bad_word)) {
            throw new \InvalidArgumentException('non-nullable bad_word cannot be null');
        }
        $this->container['bad_word'] = $bad_word;

        return $this;
    }

    /**
     * Gets word
     *
     * @return string|null
     */
    public function getWord()
    {
        return $this->container['word'];
    }

    /**
     * Sets word
     *
     * @param string|null $word word
     *
     * @return self
     */
    public function setWord($word)
    {
        if (is_null($word)) {
            throw new \InvalidArgumentException('non-nullable word cannot be null');
        }
        $this->container['word'] = $word;

        return $this;
    }

    /**
     * Gets locale
     *
     * @return string|null
     */
    public function getLocale()
    {
        return $this->container['locale'];
    }

    /**
     * Sets locale
     *
     * @param string|null $locale locale
     *
     * @return self
     */
    public function setLocale($locale)
    {
        if (is_null($locale)) {
            throw new \InvalidArgumentException('non-nullable locale cannot be null');
        }
        $this->container['locale'] = $locale;

        return $this;
    }

    /**
     * Gets tenant_badge_id
     *
     * @return string|null
     */
    public function getTenantBadgeId()
    {
        return $this->container['tenant_badge_id'];
    }

    /**
     * Sets tenant_badge_id
     *
     * @param string|null $tenant_badge_id tenant_badge_id
     *
     * @return self
     */
    public function setTenantBadgeId($tenant_badge_id)
    {
        if (is_null($tenant_badge_id)) {
            throw new \InvalidArgumentException('non-nullable tenant_badge_id cannot be null');
        }
        $this->container['tenant_badge_id'] = $tenant_badge_id;

        return $this;
    }

    /**
     * Gets badge_id
     *
     * @return string|null
     */
    public function getBadgeId()
    {
        return $this->container['badge_id'];
    }

    /**
     * Sets badge_id
     *
     * @param string|null $badge_id badge_id
     *
     * @return self
     */
    public function setBadgeId($badge_id)
    {
        if (is_null($badge_id)) {
            throw new \InvalidArgumentException('non-nullable badge_id cannot be null');
        }
        $this->container['badge_id'] = $badge_id;

        return $this;
    }

    /**
     * Gets was_logged_in
     *
     * @return bool|null
     */
    public function getWasLoggedIn()
    {
        return $this->container['was_logged_in'];
    }

    /**
     * Sets was_logged_in
     *
     * @param bool|null $was_logged_in was_logged_in
     *
     * @return self
     */
    public function setWasLoggedIn($was_logged_in)
    {
        if (is_null($was_logged_in)) {
            throw new \InvalidArgumentException('non-nullable was_logged_in cannot be null');
        }
        $this->container['was_logged_in'] = $was_logged_in;

        return $this;
    }

    /**
     * Gets found_user
     *
     * @return bool|null
     */
    public function getFoundUser()
    {
        return $this->container['found_user'];
    }

    /**
     * Sets found_user
     *
     * @param bool|null $found_user found_user
     *
     * @return self
     */
    public function setFoundUser($found_user)
    {
        if (is_null($found_user)) {
            throw new \InvalidArgumentException('non-nullable found_user cannot be null');
        }
        $this->container['found_user'] = $found_user;

        return $this;
    }

    /**
     * Gets verified
     *
     * @return bool|null
     */
    public function getVerified()
    {
        return $this->container['verified'];
    }

    /**
     * Sets verified
     *
     * @param bool|null $verified verified
     *
     * @return self
     */
    public function setVerified($verified)
    {
        if (is_null($verified)) {
            throw new \InvalidArgumentException('non-nullable verified cannot be null');
        }
        $this->container['verified'] = $verified;

        return $this;
    }

    /**
     * Gets engine
     *
     * @return string|null
     */
    public function getEngine()
    {
        return $this->container['engine'];
    }

    /**
     * Sets engine
     *
     * @param string|null $engine engine
     *
     * @return self
     */
    public function setEngine($engine)
    {
        if (is_null($engine)) {
            throw new \InvalidArgumentException('non-nullable engine cannot be null');
        }
        $this->container['engine'] = $engine;

        return $this;
    }

    /**
     * Gets engine_response
     *
     * @return string|null
     */
    public function getEngineResponse()
    {
        return $this->container['engine_response'];
    }

    /**
     * Sets engine_response
     *
     * @param string|null $engine_response engine_response
     *
     * @return self
     */
    public function setEngineResponse($engine_response)
    {
        if (is_null($engine_response)) {
            throw new \InvalidArgumentException('non-nullable engine_response cannot be null');
        }
        $this->container['engine_response'] = $engine_response;

        return $this;
    }

    /**
     * Gets engine_tokens
     *
     * @return float|null
     */
    public function getEngineTokens()
    {
        return $this->container['engine_tokens'];
    }

    /**
     * Sets engine_tokens
     *
     * @param float|null $engine_tokens engine_tokens
     *
     * @return self
     */
    public function setEngineTokens($engine_tokens)
    {
        if (is_null($engine_tokens)) {
            throw new \InvalidArgumentException('non-nullable engine_tokens cannot be null');
        }
        $this->container['engine_tokens'] = $engine_tokens;

        return $this;
    }

    /**
     * Gets trust_factor
     *
     * @return float|null
     */
    public function getTrustFactor()
    {
        return $this->container['trust_factor'];
    }

    /**
     * Sets trust_factor
     *
     * @param float|null $trust_factor trust_factor
     *
     * @return self
     */
    public function setTrustFactor($trust_factor)
    {
        if (is_null($trust_factor)) {
            throw new \InvalidArgumentException('non-nullable trust_factor cannot be null');
        }
        $this->container['trust_factor'] = $trust_factor;

        return $this;
    }

    /**
     * Gets rule
     *
     * @return \FastComments\Client\Model\SpamRule|null
     */
    public function getRule()
    {
        return $this->container['rule'];
    }

    /**
     * Sets rule
     *
     * @param \FastComments\Client\Model\SpamRule|null $rule rule
     *
     * @return self
     */
    public function setRule($rule)
    {
        if (is_null($rule)) {
            throw new \InvalidArgumentException('non-nullable rule cannot be null');
        }
        $this->container['rule'] = $rule;

        return $this;
    }

    /**
     * Gets user_id
     *
     * @return string|null
     */
    public function getUserId()
    {
        return $this->container['user_id'];
    }

    /**
     * Sets user_id
     *
     * @param string|null $user_id user_id
     *
     * @return self
     */
    public function setUserId($user_id)
    {
        if (is_null($user_id)) {
            throw new \InvalidArgumentException('non-nullable user_id cannot be null');
        }
        $this->container['user_id'] = $user_id;

        return $this;
    }

    /**
     * Gets subscribers
     *
     * @return float|null
     */
    public function getSubscribers()
    {
        return $this->container['subscribers'];
    }

    /**
     * Sets subscribers
     *
     * @param float|null $subscribers subscribers
     *
     * @return self
     */
    public function setSubscribers($subscribers)
    {
        if (is_null($subscribers)) {
            throw new \InvalidArgumentException('non-nullable subscribers cannot be null');
        }
        $this->container['subscribers'] = $subscribers;

        return $this;
    }

    /**
     * Gets notification_count
     *
     * @return float|null
     */
    public function getNotificationCount()
    {
        return $this->container['notification_count'];
    }

    /**
     * Sets notification_count
     *
     * @param float|null $notification_count notification_count
     *
     * @return self
     */
    public function setNotificationCount($notification_count)
    {
        if (is_null($notification_count)) {
            throw new \InvalidArgumentException('non-nullable notification_count cannot be null');
        }
        $this->container['notification_count'] = $notification_count;

        return $this;
    }

    /**
     * Gets votes_before
     *
     * @return float|null
     */
    public function getVotesBefore()
    {
        return $this->container['votes_before'];
    }

    /**
     * Sets votes_before
     *
     * @param float|null $votes_before votes_before
     *
     * @return self
     */
    public function setVotesBefore($votes_before)
    {
        if (is_null($votes_before)) {
            array_push($this->openAPINullablesSetToNull, 'votes_before');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('votes_before', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['votes_before'] = $votes_before;

        return $this;
    }

    /**
     * Gets votes_up_before
     *
     * @return float|null
     */
    public function getVotesUpBefore()
    {
        return $this->container['votes_up_before'];
    }

    /**
     * Sets votes_up_before
     *
     * @param float|null $votes_up_before votes_up_before
     *
     * @return self
     */
    public function setVotesUpBefore($votes_up_before)
    {
        if (is_null($votes_up_before)) {
            array_push($this->openAPINullablesSetToNull, 'votes_up_before');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('votes_up_before', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['votes_up_before'] = $votes_up_before;

        return $this;
    }

    /**
     * Gets votes_down_before
     *
     * @return float|null
     */
    public function getVotesDownBefore()
    {
        return $this->container['votes_down_before'];
    }

    /**
     * Sets votes_down_before
     *
     * @param float|null $votes_down_before votes_down_before
     *
     * @return self
     */
    public function setVotesDownBefore($votes_down_before)
    {
        if (is_null($votes_down_before)) {
            array_push($this->openAPINullablesSetToNull, 'votes_down_before');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('votes_down_before', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['votes_down_before'] = $votes_down_before;

        return $this;
    }

    /**
     * Gets votes_after
     *
     * @return float|null
     */
    public function getVotesAfter()
    {
        return $this->container['votes_after'];
    }

    /**
     * Sets votes_after
     *
     * @param float|null $votes_after votes_after
     *
     * @return self
     */
    public function setVotesAfter($votes_after)
    {
        if (is_null($votes_after)) {
            array_push($this->openAPINullablesSetToNull, 'votes_after');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('votes_after', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['votes_after'] = $votes_after;

        return $this;
    }

    /**
     * Gets votes_up_after
     *
     * @return float|null
     */
    public function getVotesUpAfter()
    {
        return $this->container['votes_up_after'];
    }

    /**
     * Sets votes_up_after
     *
     * @param float|null $votes_up_after votes_up_after
     *
     * @return self
     */
    public function setVotesUpAfter($votes_up_after)
    {
        if (is_null($votes_up_after)) {
            array_push($this->openAPINullablesSetToNull, 'votes_up_after');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('votes_up_after', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['votes_up_after'] = $votes_up_after;

        return $this;
    }

    /**
     * Gets votes_down_after
     *
     * @return float|null
     */
    public function getVotesDownAfter()
    {
        return $this->container['votes_down_after'];
    }

    /**
     * Sets votes_down_after
     *
     * @param float|null $votes_down_after votes_down_after
     *
     * @return self
     */
    public function setVotesDownAfter($votes_down_after)
    {
        if (is_null($votes_down_after)) {
            array_push($this->openAPINullablesSetToNull, 'votes_down_after');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('votes_down_after', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['votes_down_after'] = $votes_down_after;

        return $this;
    }

    /**
     * Gets repeat_action
     *
     * @return \FastComments\Client\Model\RepeatCommentHandlingAction|null
     */
    public function getRepeatAction()
    {
        return $this->container['repeat_action'];
    }

    /**
     * Sets repeat_action
     *
     * @param \FastComments\Client\Model\RepeatCommentHandlingAction|null $repeat_action repeat_action
     *
     * @return self
     */
    public function setRepeatAction($repeat_action)
    {
        if (is_null($repeat_action)) {
            throw new \InvalidArgumentException('non-nullable repeat_action cannot be null');
        }
        $this->container['repeat_action'] = $repeat_action;

        return $this;
    }

    /**
     * Gets reason
     *
     * @return \FastComments\Client\Model\RepeatCommentCheckIgnoredReason|null
     */
    public function getReason()
    {
        return $this->container['reason'];
    }

    /**
     * Sets reason
     *
     * @param \FastComments\Client\Model\RepeatCommentCheckIgnoredReason|null $reason reason
     *
     * @return self
     */
    public function setReason($reason)
    {
        if (is_null($reason)) {
            throw new \InvalidArgumentException('non-nullable reason cannot be null');
        }
        $this->container['reason'] = $reason;

        return $this;
    }

    /**
     * Gets other_data
     *
     * @return mixed|null
     */
    public function getOtherData()
    {
        return $this->container['other_data'];
    }

    /**
     * Sets other_data
     *
     * @param mixed|null $other_data other_data
     *
     * @return self
     */
    public function setOtherData($other_data)
    {
        if (is_null($other_data)) {
            array_push($this->openAPINullablesSetToNull, 'other_data');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('other_data', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['other_data'] = $other_data;

        return $this;
    }

    /**
     * Gets spam_before
     *
     * @return bool|null
     */
    public function getSpamBefore()
    {
        return $this->container['spam_before'];
    }

    /**
     * Sets spam_before
     *
     * @param bool|null $spam_before spam_before
     *
     * @return self
     */
    public function setSpamBefore($spam_before)
    {
        if (is_null($spam_before)) {
            throw new \InvalidArgumentException('non-nullable spam_before cannot be null');
        }
        $this->container['spam_before'] = $spam_before;

        return $this;
    }

    /**
     * Gets spam_after
     *
     * @return bool|null
     */
    public function getSpamAfter()
    {
        return $this->container['spam_after'];
    }

    /**
     * Sets spam_after
     *
     * @param bool|null $spam_after spam_after
     *
     * @return self
     */
    public function setSpamAfter($spam_after)
    {
        if (is_null($spam_after)) {
            throw new \InvalidArgumentException('non-nullable spam_after cannot be null');
        }
        $this->container['spam_after'] = $spam_after;

        return $this;
    }

    /**
     * Gets permanent_flag
     *
     * @return string|null
     */
    public function getPermanentFlag()
    {
        return $this->container['permanent_flag'];
    }

    /**
     * Sets permanent_flag
     *
     * @param string|null $permanent_flag permanent_flag
     *
     * @return self
     */
    public function setPermanentFlag($permanent_flag)
    {
        if (is_null($permanent_flag)) {
            throw new \InvalidArgumentException('non-nullable permanent_flag cannot be null');
        }
        $allowedValues = $this->getPermanentFlagAllowableValues();
        if (!in_array($permanent_flag, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'permanent_flag', must be one of '%s'",
                    $permanent_flag,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['permanent_flag'] = $permanent_flag;

        return $this;
    }

    /**
     * Gets approved_before
     *
     * @return bool|null
     */
    public function getApprovedBefore()
    {
        return $this->container['approved_before'];
    }

    /**
     * Sets approved_before
     *
     * @param bool|null $approved_before approved_before
     *
     * @return self
     */
    public function setApprovedBefore($approved_before)
    {
        if (is_null($approved_before)) {
            throw new \InvalidArgumentException('non-nullable approved_before cannot be null');
        }
        $this->container['approved_before'] = $approved_before;

        return $this;
    }

    /**
     * Gets approved_after
     *
     * @return bool|null
     */
    public function getApprovedAfter()
    {
        return $this->container['approved_after'];
    }

    /**
     * Sets approved_after
     *
     * @param bool|null $approved_after approved_after
     *
     * @return self
     */
    public function setApprovedAfter($approved_after)
    {
        if (is_null($approved_after)) {
            throw new \InvalidArgumentException('non-nullable approved_after cannot be null');
        }
        $this->container['approved_after'] = $approved_after;

        return $this;
    }

    /**
     * Gets reviewed_before
     *
     * @return bool|null
     */
    public function getReviewedBefore()
    {
        return $this->container['reviewed_before'];
    }

    /**
     * Sets reviewed_before
     *
     * @param bool|null $reviewed_before reviewed_before
     *
     * @return self
     */
    public function setReviewedBefore($reviewed_before)
    {
        if (is_null($reviewed_before)) {
            throw new \InvalidArgumentException('non-nullable reviewed_before cannot be null');
        }
        $this->container['reviewed_before'] = $reviewed_before;

        return $this;
    }

    /**
     * Gets reviewed_after
     *
     * @return bool|null
     */
    public function getReviewedAfter()
    {
        return $this->container['reviewed_after'];
    }

    /**
     * Sets reviewed_after
     *
     * @param bool|null $reviewed_after reviewed_after
     *
     * @return self
     */
    public function setReviewedAfter($reviewed_after)
    {
        if (is_null($reviewed_after)) {
            throw new \InvalidArgumentException('non-nullable reviewed_after cannot be null');
        }
        $this->container['reviewed_after'] = $reviewed_after;

        return $this;
    }

    /**
     * Gets text_before
     *
     * @return string|null
     */
    public function getTextBefore()
    {
        return $this->container['text_before'];
    }

    /**
     * Sets text_before
     *
     * @param string|null $text_before text_before
     *
     * @return self
     */
    public function setTextBefore($text_before)
    {
        if (is_null($text_before)) {
            throw new \InvalidArgumentException('non-nullable text_before cannot be null');
        }
        $this->container['text_before'] = $text_before;

        return $this;
    }

    /**
     * Gets text_after
     *
     * @return string|null
     */
    public function getTextAfter()
    {
        return $this->container['text_after'];
    }

    /**
     * Sets text_after
     *
     * @param string|null $text_after text_after
     *
     * @return self
     */
    public function setTextAfter($text_after)
    {
        if (is_null($text_after)) {
            throw new \InvalidArgumentException('non-nullable text_after cannot be null');
        }
        $this->container['text_after'] = $text_after;

        return $this;
    }

    /**
     * Gets expire_before
     *
     * @return \DateTime|null
     */
    public function getExpireBefore()
    {
        return $this->container['expire_before'];
    }

    /**
     * Sets expire_before
     *
     * @param \DateTime|null $expire_before expire_before
     *
     * @return self
     */
    public function setExpireBefore($expire_before)
    {
        if (is_null($expire_before)) {
            array_push($this->openAPINullablesSetToNull, 'expire_before');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('expire_before', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['expire_before'] = $expire_before;

        return $this;
    }

    /**
     * Gets expire_after
     *
     * @return \DateTime|null
     */
    public function getExpireAfter()
    {
        return $this->container['expire_after'];
    }

    /**
     * Sets expire_after
     *
     * @param \DateTime|null $expire_after expire_after
     *
     * @return self
     */
    public function setExpireAfter($expire_after)
    {
        if (is_null($expire_after)) {
            array_push($this->openAPINullablesSetToNull, 'expire_after');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('expire_after', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['expire_after'] = $expire_after;

        return $this;
    }

    /**
     * Gets flag_count_before
     *
     * @return float|null
     */
    public function getFlagCountBefore()
    {
        return $this->container['flag_count_before'];
    }

    /**
     * Sets flag_count_before
     *
     * @param float|null $flag_count_before flag_count_before
     *
     * @return self
     */
    public function setFlagCountBefore($flag_count_before)
    {
        if (is_null($flag_count_before)) {
            array_push($this->openAPINullablesSetToNull, 'flag_count_before');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('flag_count_before', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['flag_count_before'] = $flag_count_before;

        return $this;
    }

    /**
     * Gets trust_factor_before
     *
     * @return float|null
     */
    public function getTrustFactorBefore()
    {
        return $this->container['trust_factor_before'];
    }

    /**
     * Sets trust_factor_before
     *
     * @param float|null $trust_factor_before trust_factor_before
     *
     * @return self
     */
    public function setTrustFactorBefore($trust_factor_before)
    {
        if (is_null($trust_factor_before)) {
            throw new \InvalidArgumentException('non-nullable trust_factor_before cannot be null');
        }
        $this->container['trust_factor_before'] = $trust_factor_before;

        return $this;
    }

    /**
     * Gets trust_factor_after
     *
     * @return float|null
     */
    public function getTrustFactorAfter()
    {
        return $this->container['trust_factor_after'];
    }

    /**
     * Sets trust_factor_after
     *
     * @param float|null $trust_factor_after trust_factor_after
     *
     * @return self
     */
    public function setTrustFactorAfter($trust_factor_after)
    {
        if (is_null($trust_factor_after)) {
            throw new \InvalidArgumentException('non-nullable trust_factor_after cannot be null');
        }
        $this->container['trust_factor_after'] = $trust_factor_after;

        return $this;
    }

    /**
     * Gets referenced_comment_id
     *
     * @return string|null
     */
    public function getReferencedCommentId()
    {
        return $this->container['referenced_comment_id'];
    }

    /**
     * Sets referenced_comment_id
     *
     * @param string|null $referenced_comment_id referenced_comment_id
     *
     * @return self
     */
    public function setReferencedCommentId($referenced_comment_id)
    {
        if (is_null($referenced_comment_id)) {
            throw new \InvalidArgumentException('non-nullable referenced_comment_id cannot be null');
        }
        $this->container['referenced_comment_id'] = $referenced_comment_id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


