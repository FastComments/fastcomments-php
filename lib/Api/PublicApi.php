<?php
/**
 * PublicApi
 * PHP version 7.4
 *
 * @category Class
 * @package  FastComments\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * fastcomments
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * Contact: support@fastcomments.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace FastComments\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FastComments\Client\ApiException;
use FastComments\Client\Configuration;
use FastComments\Client\HeaderSelector;
use FastComments\Client\ObjectSerializer;

/**
 * PublicApi Class Doc Comment
 *
 * @category Class
 * @package  FastComments\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PublicApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'blockFromCommentPublic' => [
            'application/json',
        ],
        'checkedCommentsForBlocked' => [
            'application/json',
        ],
        'createCommentPublic' => [
            'application/json',
        ],
        'deleteCommentPublic' => [
            'application/json',
        ],
        'deleteCommentVote' => [
            'application/json',
        ],
        'flagCommentPublic' => [
            'application/json',
        ],
        'getCommentText' => [
            'application/json',
        ],
        'getCommentVoteUserNames' => [
            'application/json',
        ],
        'getCommentsPublic' => [
            'application/json',
        ],
        'getEventLog' => [
            'application/json',
        ],
        'getFeedPostsPublic' => [
            'application/json',
        ],
        'getGlobalEventLog' => [
            'application/json',
        ],
        'getUserNotificationCount' => [
            'application/json',
        ],
        'getUserNotifications' => [
            'application/json',
        ],
        'getUserPresenceStatuses' => [
            'application/json',
        ],
        'lockComment' => [
            'application/json',
        ],
        'pinComment' => [
            'application/json',
        ],
        'resetUserNotificationCount' => [
            'application/json',
        ],
        'resetUserNotifications' => [
            'application/json',
        ],
        'setCommentText' => [
            'application/json',
        ],
        'unBlockCommentPublic' => [
            'application/json',
        ],
        'unLockComment' => [
            'application/json',
        ],
        'unPinComment' => [
            'application/json',
        ],
        'updateUserNotificationCommentSubscriptionStatus' => [
            'application/json',
        ],
        'updateUserNotificationPageSubscriptionStatus' => [
            'application/json',
        ],
        'updateUserNotificationStatus' => [
            'application/json',
        ],
        'voteComment' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation blockFromCommentPublic
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params public_block_from_comment_params (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockFromCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\BlockFromCommentPublic200Response
     */
    public function blockFromCommentPublic($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['blockFromCommentPublic'][0])
    {
        list($response) = $this->blockFromCommentPublicWithHttpInfo($tenant_id, $comment_id, $public_block_from_comment_params, $sso, $contentType);
        return $response;
    }

    /**
     * Operation blockFromCommentPublicWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockFromCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\BlockFromCommentPublic200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function blockFromCommentPublicWithHttpInfo($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['blockFromCommentPublic'][0])
    {
        $request = $this->blockFromCommentPublicRequest($tenant_id, $comment_id, $public_block_from_comment_params, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\BlockFromCommentPublic200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\BlockFromCommentPublic200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\BlockFromCommentPublic200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\BlockFromCommentPublic200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\BlockFromCommentPublic200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation blockFromCommentPublicAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockFromCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function blockFromCommentPublicAsync($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['blockFromCommentPublic'][0])
    {
        return $this->blockFromCommentPublicAsyncWithHttpInfo($tenant_id, $comment_id, $public_block_from_comment_params, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation blockFromCommentPublicAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockFromCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function blockFromCommentPublicAsyncWithHttpInfo($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['blockFromCommentPublic'][0])
    {
        $returnType = '\FastComments\Client\Model\BlockFromCommentPublic200Response';
        $request = $this->blockFromCommentPublicRequest($tenant_id, $comment_id, $public_block_from_comment_params, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'blockFromCommentPublic'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockFromCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function blockFromCommentPublicRequest($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['blockFromCommentPublic'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling blockFromCommentPublic'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling blockFromCommentPublic'
            );
        }

        // verify the required parameter 'public_block_from_comment_params' is set
        if ($public_block_from_comment_params === null || (is_array($public_block_from_comment_params) && count($public_block_from_comment_params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $public_block_from_comment_params when calling blockFromCommentPublic'
            );
        }



        $resourcePath = '/block-from-comment/{commentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_block_from_comment_params)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_block_from_comment_params));
            } else {
                $httpBody = $public_block_from_comment_params;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkedCommentsForBlocked
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_ids A comma separated list of comment ids. (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkedCommentsForBlocked'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\CheckedCommentsForBlocked200Response
     */
    public function checkedCommentsForBlocked($tenant_id, $comment_ids, $sso = null, string $contentType = self::contentTypes['checkedCommentsForBlocked'][0])
    {
        list($response) = $this->checkedCommentsForBlockedWithHttpInfo($tenant_id, $comment_ids, $sso, $contentType);
        return $response;
    }

    /**
     * Operation checkedCommentsForBlockedWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_ids A comma separated list of comment ids. (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkedCommentsForBlocked'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\CheckedCommentsForBlocked200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkedCommentsForBlockedWithHttpInfo($tenant_id, $comment_ids, $sso = null, string $contentType = self::contentTypes['checkedCommentsForBlocked'][0])
    {
        $request = $this->checkedCommentsForBlockedRequest($tenant_id, $comment_ids, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\CheckedCommentsForBlocked200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\CheckedCommentsForBlocked200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\CheckedCommentsForBlocked200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\CheckedCommentsForBlocked200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\CheckedCommentsForBlocked200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkedCommentsForBlockedAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_ids A comma separated list of comment ids. (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkedCommentsForBlocked'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkedCommentsForBlockedAsync($tenant_id, $comment_ids, $sso = null, string $contentType = self::contentTypes['checkedCommentsForBlocked'][0])
    {
        return $this->checkedCommentsForBlockedAsyncWithHttpInfo($tenant_id, $comment_ids, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkedCommentsForBlockedAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_ids A comma separated list of comment ids. (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkedCommentsForBlocked'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkedCommentsForBlockedAsyncWithHttpInfo($tenant_id, $comment_ids, $sso = null, string $contentType = self::contentTypes['checkedCommentsForBlocked'][0])
    {
        $returnType = '\FastComments\Client\Model\CheckedCommentsForBlocked200Response';
        $request = $this->checkedCommentsForBlockedRequest($tenant_id, $comment_ids, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkedCommentsForBlocked'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_ids A comma separated list of comment ids. (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkedCommentsForBlocked'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkedCommentsForBlockedRequest($tenant_id, $comment_ids, $sso = null, string $contentType = self::contentTypes['checkedCommentsForBlocked'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling checkedCommentsForBlocked'
            );
        }

        // verify the required parameter 'comment_ids' is set
        if ($comment_ids === null || (is_array($comment_ids) && count($comment_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_ids when calling checkedCommentsForBlocked'
            );
        }



        $resourcePath = '/check-blocked-comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment_ids,
            'commentIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCommentPublic
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $url_id url_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentData $comment_data comment_data (required)
     * @param  string|null $session_id session_id (optional)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\CreateCommentPublic200Response
     */
    public function createCommentPublic($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id = null, $sso = null, string $contentType = self::contentTypes['createCommentPublic'][0])
    {
        list($response) = $this->createCommentPublicWithHttpInfo($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation createCommentPublicWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentData $comment_data (required)
     * @param  string|null $session_id (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\CreateCommentPublic200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCommentPublicWithHttpInfo($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id = null, $sso = null, string $contentType = self::contentTypes['createCommentPublic'][0])
    {
        $request = $this->createCommentPublicRequest($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\CreateCommentPublic200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\CreateCommentPublic200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\CreateCommentPublic200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\CreateCommentPublic200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\CreateCommentPublic200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCommentPublicAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentData $comment_data (required)
     * @param  string|null $session_id (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCommentPublicAsync($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id = null, $sso = null, string $contentType = self::contentTypes['createCommentPublic'][0])
    {
        return $this->createCommentPublicAsyncWithHttpInfo($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCommentPublicAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentData $comment_data (required)
     * @param  string|null $session_id (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCommentPublicAsyncWithHttpInfo($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id = null, $sso = null, string $contentType = self::contentTypes['createCommentPublic'][0])
    {
        $returnType = '\FastComments\Client\Model\CreateCommentPublic200Response';
        $request = $this->createCommentPublicRequest($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCommentPublic'
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentData $comment_data (required)
     * @param  string|null $session_id (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCommentPublicRequest($tenant_id, $url_id, $broadcast_id, $comment_data, $session_id = null, $sso = null, string $contentType = self::contentTypes['createCommentPublic'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling createCommentPublic'
            );
        }

        // verify the required parameter 'url_id' is set
        if ($url_id === null || (is_array($url_id) && count($url_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url_id when calling createCommentPublic'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling createCommentPublic'
            );
        }

        // verify the required parameter 'comment_data' is set
        if ($comment_data === null || (is_array($comment_data) && count($comment_data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_data when calling createCommentPublic'
            );
        }




        $resourcePath = '/comments/{tenantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_id,
            'urlId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $session_id,
            'sessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($comment_data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($comment_data));
            } else {
                $httpBody = $comment_data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCommentPublic
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  string|null $edit_key edit_key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\DeleteCommentPublic200Response
     */
    public function deleteCommentPublic($tenant_id, $comment_id, $broadcast_id, $edit_key = null, string $contentType = self::contentTypes['deleteCommentPublic'][0])
    {
        list($response) = $this->deleteCommentPublicWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $edit_key, $contentType);
        return $response;
    }

    /**
     * Operation deleteCommentPublicWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\DeleteCommentPublic200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCommentPublicWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $edit_key = null, string $contentType = self::contentTypes['deleteCommentPublic'][0])
    {
        $request = $this->deleteCommentPublicRequest($tenant_id, $comment_id, $broadcast_id, $edit_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\DeleteCommentPublic200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\DeleteCommentPublic200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\DeleteCommentPublic200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\DeleteCommentPublic200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\DeleteCommentPublic200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCommentPublicAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentPublicAsync($tenant_id, $comment_id, $broadcast_id, $edit_key = null, string $contentType = self::contentTypes['deleteCommentPublic'][0])
    {
        return $this->deleteCommentPublicAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $edit_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCommentPublicAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentPublicAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $edit_key = null, string $contentType = self::contentTypes['deleteCommentPublic'][0])
    {
        $returnType = '\FastComments\Client\Model\DeleteCommentPublic200Response';
        $request = $this->deleteCommentPublicRequest($tenant_id, $comment_id, $broadcast_id, $edit_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCommentPublic'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCommentPublicRequest($tenant_id, $comment_id, $broadcast_id, $edit_key = null, string $contentType = self::contentTypes['deleteCommentPublic'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling deleteCommentPublic'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling deleteCommentPublic'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling deleteCommentPublic'
            );
        }



        $resourcePath = '/comments/{tenantId}/{commentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $edit_key,
            'editKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCommentVote
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string $vote_id vote_id (required)
     * @param  string $url_id url_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  string|null $edit_key edit_key (optional)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentVote'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\DeleteCommentVote200Response
     */
    public function deleteCommentVote($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['deleteCommentVote'][0])
    {
        list($response) = $this->deleteCommentVoteWithHttpInfo($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key, $sso, $contentType);
        return $response;
    }

    /**
     * Operation deleteCommentVoteWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $vote_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentVote'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\DeleteCommentVote200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCommentVoteWithHttpInfo($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['deleteCommentVote'][0])
    {
        $request = $this->deleteCommentVoteRequest($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\DeleteCommentVote200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\DeleteCommentVote200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\DeleteCommentVote200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\DeleteCommentVote200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\DeleteCommentVote200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCommentVoteAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $vote_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentVote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentVoteAsync($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['deleteCommentVote'][0])
    {
        return $this->deleteCommentVoteAsyncWithHttpInfo($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCommentVoteAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $vote_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentVote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentVoteAsyncWithHttpInfo($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['deleteCommentVote'][0])
    {
        $returnType = '\FastComments\Client\Model\DeleteCommentVote200Response';
        $request = $this->deleteCommentVoteRequest($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCommentVote'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $vote_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCommentVote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCommentVoteRequest($tenant_id, $comment_id, $vote_id, $url_id, $broadcast_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['deleteCommentVote'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling deleteCommentVote'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling deleteCommentVote'
            );
        }

        // verify the required parameter 'vote_id' is set
        if ($vote_id === null || (is_array($vote_id) && count($vote_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vote_id when calling deleteCommentVote'
            );
        }

        // verify the required parameter 'url_id' is set
        if ($url_id === null || (is_array($url_id) && count($url_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url_id when calling deleteCommentVote'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling deleteCommentVote'
            );
        }




        $resourcePath = '/comments/{tenantId}/{commentId}/vote/{voteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_id,
            'urlId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $edit_key,
            'editKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }
        // path params
        if ($vote_id !== null) {
            $resourcePath = str_replace(
                '{' . 'voteId' . '}',
                ObjectSerializer::toPathValue($vote_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation flagCommentPublic
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  bool $is_flagged is_flagged (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flagCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\FlagCommentPublic200Response
     */
    public function flagCommentPublic($tenant_id, $comment_id, $is_flagged, $sso = null, string $contentType = self::contentTypes['flagCommentPublic'][0])
    {
        list($response) = $this->flagCommentPublicWithHttpInfo($tenant_id, $comment_id, $is_flagged, $sso, $contentType);
        return $response;
    }

    /**
     * Operation flagCommentPublicWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  bool $is_flagged (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flagCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\FlagCommentPublic200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function flagCommentPublicWithHttpInfo($tenant_id, $comment_id, $is_flagged, $sso = null, string $contentType = self::contentTypes['flagCommentPublic'][0])
    {
        $request = $this->flagCommentPublicRequest($tenant_id, $comment_id, $is_flagged, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\FlagCommentPublic200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\FlagCommentPublic200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\FlagCommentPublic200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\FlagCommentPublic200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\FlagCommentPublic200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation flagCommentPublicAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  bool $is_flagged (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flagCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flagCommentPublicAsync($tenant_id, $comment_id, $is_flagged, $sso = null, string $contentType = self::contentTypes['flagCommentPublic'][0])
    {
        return $this->flagCommentPublicAsyncWithHttpInfo($tenant_id, $comment_id, $is_flagged, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation flagCommentPublicAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  bool $is_flagged (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flagCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flagCommentPublicAsyncWithHttpInfo($tenant_id, $comment_id, $is_flagged, $sso = null, string $contentType = self::contentTypes['flagCommentPublic'][0])
    {
        $returnType = '\FastComments\Client\Model\FlagCommentPublic200Response';
        $request = $this->flagCommentPublicRequest($tenant_id, $comment_id, $is_flagged, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'flagCommentPublic'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  bool $is_flagged (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flagCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function flagCommentPublicRequest($tenant_id, $comment_id, $is_flagged, $sso = null, string $contentType = self::contentTypes['flagCommentPublic'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling flagCommentPublic'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling flagCommentPublic'
            );
        }

        // verify the required parameter 'is_flagged' is set
        if ($is_flagged === null || (is_array($is_flagged) && count($is_flagged) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $is_flagged when calling flagCommentPublic'
            );
        }



        $resourcePath = '/flag-comment/{commentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_flagged,
            'isFlagged', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCommentText
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string|null $edit_key edit_key (optional)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentText'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetCommentText200Response
     */
    public function getCommentText($tenant_id, $comment_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['getCommentText'][0])
    {
        list($response) = $this->getCommentTextWithHttpInfo($tenant_id, $comment_id, $edit_key, $sso, $contentType);
        return $response;
    }

    /**
     * Operation getCommentTextWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentText'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetCommentText200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCommentTextWithHttpInfo($tenant_id, $comment_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['getCommentText'][0])
    {
        $request = $this->getCommentTextRequest($tenant_id, $comment_id, $edit_key, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetCommentText200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetCommentText200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetCommentText200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetCommentText200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetCommentText200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCommentTextAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentTextAsync($tenant_id, $comment_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['getCommentText'][0])
    {
        return $this->getCommentTextAsyncWithHttpInfo($tenant_id, $comment_id, $edit_key, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCommentTextAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentTextAsyncWithHttpInfo($tenant_id, $comment_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['getCommentText'][0])
    {
        $returnType = '\FastComments\Client\Model\GetCommentText200Response';
        $request = $this->getCommentTextRequest($tenant_id, $comment_id, $edit_key, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCommentText'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCommentTextRequest($tenant_id, $comment_id, $edit_key = null, $sso = null, string $contentType = self::contentTypes['getCommentText'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getCommentText'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling getCommentText'
            );
        }




        $resourcePath = '/comments/{tenantId}/{commentId}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $edit_key,
            'editKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCommentVoteUserNames
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  float $direction Pass 1 for getting the names of users that up voted, and -1 for the usernames for users that down voted. (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentVoteUserNames'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetCommentVoteUserNames200Response
     */
    public function getCommentVoteUserNames($tenant_id, $comment_id, $direction, $sso = null, string $contentType = self::contentTypes['getCommentVoteUserNames'][0])
    {
        list($response) = $this->getCommentVoteUserNamesWithHttpInfo($tenant_id, $comment_id, $direction, $sso, $contentType);
        return $response;
    }

    /**
     * Operation getCommentVoteUserNamesWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  float $direction Pass 1 for getting the names of users that up voted, and -1 for the usernames for users that down voted. (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentVoteUserNames'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetCommentVoteUserNames200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCommentVoteUserNamesWithHttpInfo($tenant_id, $comment_id, $direction, $sso = null, string $contentType = self::contentTypes['getCommentVoteUserNames'][0])
    {
        $request = $this->getCommentVoteUserNamesRequest($tenant_id, $comment_id, $direction, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetCommentVoteUserNames200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetCommentVoteUserNames200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetCommentVoteUserNames200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetCommentVoteUserNames200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetCommentVoteUserNames200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCommentVoteUserNamesAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  float $direction Pass 1 for getting the names of users that up voted, and -1 for the usernames for users that down voted. (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentVoteUserNames'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentVoteUserNamesAsync($tenant_id, $comment_id, $direction, $sso = null, string $contentType = self::contentTypes['getCommentVoteUserNames'][0])
    {
        return $this->getCommentVoteUserNamesAsyncWithHttpInfo($tenant_id, $comment_id, $direction, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCommentVoteUserNamesAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  float $direction Pass 1 for getting the names of users that up voted, and -1 for the usernames for users that down voted. (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentVoteUserNames'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentVoteUserNamesAsyncWithHttpInfo($tenant_id, $comment_id, $direction, $sso = null, string $contentType = self::contentTypes['getCommentVoteUserNames'][0])
    {
        $returnType = '\FastComments\Client\Model\GetCommentVoteUserNames200Response';
        $request = $this->getCommentVoteUserNamesRequest($tenant_id, $comment_id, $direction, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCommentVoteUserNames'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  float $direction Pass 1 for getting the names of users that up voted, and -1 for the usernames for users that down voted. (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentVoteUserNames'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCommentVoteUserNamesRequest($tenant_id, $comment_id, $direction, $sso = null, string $contentType = self::contentTypes['getCommentVoteUserNames'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getCommentVoteUserNames'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling getCommentVoteUserNames'
            );
        }

        // verify the required parameter 'direction' is set
        if ($direction === null || (is_array($direction) && count($direction) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $direction when calling getCommentVoteUserNames'
            );
        }



        $resourcePath = '/comments/{tenantId}/{commentId}/votes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCommentsPublic
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $url_id url_id (required)
     * @param  int|null $page page (optional)
     * @param  \FastComments\Client\Model\SortDirections|null $direction direction (optional)
     * @param  string|null $sso sso (optional)
     * @param  int|null $skip skip (optional)
     * @param  int|null $skip_children skip_children (optional)
     * @param  int|null $limit limit (optional)
     * @param  int|null $limit_children limit_children (optional)
     * @param  bool|null $count_children count_children (optional)
     * @param  int|null $last_gen_date last_gen_date (optional)
     * @param  string|null $fetch_page_for_comment_id fetch_page_for_comment_id (optional)
     * @param  bool|null $include_config include_config (optional)
     * @param  bool|null $count_all count_all (optional)
     * @param  bool|null $includei10n includei10n (optional)
     * @param  string|null $locale locale (optional)
     * @param  string|null $modules modules (optional)
     * @param  bool|null $is_crawler is_crawler (optional)
     * @param  bool|null $include_notification_count include_notification_count (optional)
     * @param  bool|null $as_tree as_tree (optional)
     * @param  int|null $max_tree_depth max_tree_depth (optional)
     * @param  bool|null $use_full_translation_ids use_full_translation_ids (optional)
     * @param  string|null $parent_id parent_id (optional)
     * @param  string|null $search_text search_text (optional)
     * @param  string[]|null $hash_tags hash_tags (optional)
     * @param  string|null $user_id user_id (optional)
     * @param  string|null $custom_config_str custom_config_str (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentsPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetCommentsPublic200Response
     */
    public function getCommentsPublic($tenant_id, $url_id, $page = null, $direction = null, $sso = null, $skip = null, $skip_children = null, $limit = null, $limit_children = null, $count_children = null, $last_gen_date = null, $fetch_page_for_comment_id = null, $include_config = null, $count_all = null, $includei10n = null, $locale = null, $modules = null, $is_crawler = null, $include_notification_count = null, $as_tree = null, $max_tree_depth = null, $use_full_translation_ids = null, $parent_id = null, $search_text = null, $hash_tags = null, $user_id = null, $custom_config_str = null, string $contentType = self::contentTypes['getCommentsPublic'][0])
    {
        list($response) = $this->getCommentsPublicWithHttpInfo($tenant_id, $url_id, $page, $direction, $sso, $skip, $skip_children, $limit, $limit_children, $count_children, $last_gen_date, $fetch_page_for_comment_id, $include_config, $count_all, $includei10n, $locale, $modules, $is_crawler, $include_notification_count, $as_tree, $max_tree_depth, $use_full_translation_ids, $parent_id, $search_text, $hash_tags, $user_id, $custom_config_str, $contentType);
        return $response;
    }

    /**
     * Operation getCommentsPublicWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  int|null $page (optional)
     * @param  \FastComments\Client\Model\SortDirections|null $direction (optional)
     * @param  string|null $sso (optional)
     * @param  int|null $skip (optional)
     * @param  int|null $skip_children (optional)
     * @param  int|null $limit (optional)
     * @param  int|null $limit_children (optional)
     * @param  bool|null $count_children (optional)
     * @param  int|null $last_gen_date (optional)
     * @param  string|null $fetch_page_for_comment_id (optional)
     * @param  bool|null $include_config (optional)
     * @param  bool|null $count_all (optional)
     * @param  bool|null $includei10n (optional)
     * @param  string|null $locale (optional)
     * @param  string|null $modules (optional)
     * @param  bool|null $is_crawler (optional)
     * @param  bool|null $include_notification_count (optional)
     * @param  bool|null $as_tree (optional)
     * @param  int|null $max_tree_depth (optional)
     * @param  bool|null $use_full_translation_ids (optional)
     * @param  string|null $parent_id (optional)
     * @param  string|null $search_text (optional)
     * @param  string[]|null $hash_tags (optional)
     * @param  string|null $user_id (optional)
     * @param  string|null $custom_config_str (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentsPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetCommentsPublic200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCommentsPublicWithHttpInfo($tenant_id, $url_id, $page = null, $direction = null, $sso = null, $skip = null, $skip_children = null, $limit = null, $limit_children = null, $count_children = null, $last_gen_date = null, $fetch_page_for_comment_id = null, $include_config = null, $count_all = null, $includei10n = null, $locale = null, $modules = null, $is_crawler = null, $include_notification_count = null, $as_tree = null, $max_tree_depth = null, $use_full_translation_ids = null, $parent_id = null, $search_text = null, $hash_tags = null, $user_id = null, $custom_config_str = null, string $contentType = self::contentTypes['getCommentsPublic'][0])
    {
        $request = $this->getCommentsPublicRequest($tenant_id, $url_id, $page, $direction, $sso, $skip, $skip_children, $limit, $limit_children, $count_children, $last_gen_date, $fetch_page_for_comment_id, $include_config, $count_all, $includei10n, $locale, $modules, $is_crawler, $include_notification_count, $as_tree, $max_tree_depth, $use_full_translation_ids, $parent_id, $search_text, $hash_tags, $user_id, $custom_config_str, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetCommentsPublic200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetCommentsPublic200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetCommentsPublic200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetCommentsPublic200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetCommentsPublic200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCommentsPublicAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  int|null $page (optional)
     * @param  \FastComments\Client\Model\SortDirections|null $direction (optional)
     * @param  string|null $sso (optional)
     * @param  int|null $skip (optional)
     * @param  int|null $skip_children (optional)
     * @param  int|null $limit (optional)
     * @param  int|null $limit_children (optional)
     * @param  bool|null $count_children (optional)
     * @param  int|null $last_gen_date (optional)
     * @param  string|null $fetch_page_for_comment_id (optional)
     * @param  bool|null $include_config (optional)
     * @param  bool|null $count_all (optional)
     * @param  bool|null $includei10n (optional)
     * @param  string|null $locale (optional)
     * @param  string|null $modules (optional)
     * @param  bool|null $is_crawler (optional)
     * @param  bool|null $include_notification_count (optional)
     * @param  bool|null $as_tree (optional)
     * @param  int|null $max_tree_depth (optional)
     * @param  bool|null $use_full_translation_ids (optional)
     * @param  string|null $parent_id (optional)
     * @param  string|null $search_text (optional)
     * @param  string[]|null $hash_tags (optional)
     * @param  string|null $user_id (optional)
     * @param  string|null $custom_config_str (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentsPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentsPublicAsync($tenant_id, $url_id, $page = null, $direction = null, $sso = null, $skip = null, $skip_children = null, $limit = null, $limit_children = null, $count_children = null, $last_gen_date = null, $fetch_page_for_comment_id = null, $include_config = null, $count_all = null, $includei10n = null, $locale = null, $modules = null, $is_crawler = null, $include_notification_count = null, $as_tree = null, $max_tree_depth = null, $use_full_translation_ids = null, $parent_id = null, $search_text = null, $hash_tags = null, $user_id = null, $custom_config_str = null, string $contentType = self::contentTypes['getCommentsPublic'][0])
    {
        return $this->getCommentsPublicAsyncWithHttpInfo($tenant_id, $url_id, $page, $direction, $sso, $skip, $skip_children, $limit, $limit_children, $count_children, $last_gen_date, $fetch_page_for_comment_id, $include_config, $count_all, $includei10n, $locale, $modules, $is_crawler, $include_notification_count, $as_tree, $max_tree_depth, $use_full_translation_ids, $parent_id, $search_text, $hash_tags, $user_id, $custom_config_str, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCommentsPublicAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  int|null $page (optional)
     * @param  \FastComments\Client\Model\SortDirections|null $direction (optional)
     * @param  string|null $sso (optional)
     * @param  int|null $skip (optional)
     * @param  int|null $skip_children (optional)
     * @param  int|null $limit (optional)
     * @param  int|null $limit_children (optional)
     * @param  bool|null $count_children (optional)
     * @param  int|null $last_gen_date (optional)
     * @param  string|null $fetch_page_for_comment_id (optional)
     * @param  bool|null $include_config (optional)
     * @param  bool|null $count_all (optional)
     * @param  bool|null $includei10n (optional)
     * @param  string|null $locale (optional)
     * @param  string|null $modules (optional)
     * @param  bool|null $is_crawler (optional)
     * @param  bool|null $include_notification_count (optional)
     * @param  bool|null $as_tree (optional)
     * @param  int|null $max_tree_depth (optional)
     * @param  bool|null $use_full_translation_ids (optional)
     * @param  string|null $parent_id (optional)
     * @param  string|null $search_text (optional)
     * @param  string[]|null $hash_tags (optional)
     * @param  string|null $user_id (optional)
     * @param  string|null $custom_config_str (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentsPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentsPublicAsyncWithHttpInfo($tenant_id, $url_id, $page = null, $direction = null, $sso = null, $skip = null, $skip_children = null, $limit = null, $limit_children = null, $count_children = null, $last_gen_date = null, $fetch_page_for_comment_id = null, $include_config = null, $count_all = null, $includei10n = null, $locale = null, $modules = null, $is_crawler = null, $include_notification_count = null, $as_tree = null, $max_tree_depth = null, $use_full_translation_ids = null, $parent_id = null, $search_text = null, $hash_tags = null, $user_id = null, $custom_config_str = null, string $contentType = self::contentTypes['getCommentsPublic'][0])
    {
        $returnType = '\FastComments\Client\Model\GetCommentsPublic200Response';
        $request = $this->getCommentsPublicRequest($tenant_id, $url_id, $page, $direction, $sso, $skip, $skip_children, $limit, $limit_children, $count_children, $last_gen_date, $fetch_page_for_comment_id, $include_config, $count_all, $includei10n, $locale, $modules, $is_crawler, $include_notification_count, $as_tree, $max_tree_depth, $use_full_translation_ids, $parent_id, $search_text, $hash_tags, $user_id, $custom_config_str, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCommentsPublic'
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  int|null $page (optional)
     * @param  \FastComments\Client\Model\SortDirections|null $direction (optional)
     * @param  string|null $sso (optional)
     * @param  int|null $skip (optional)
     * @param  int|null $skip_children (optional)
     * @param  int|null $limit (optional)
     * @param  int|null $limit_children (optional)
     * @param  bool|null $count_children (optional)
     * @param  int|null $last_gen_date (optional)
     * @param  string|null $fetch_page_for_comment_id (optional)
     * @param  bool|null $include_config (optional)
     * @param  bool|null $count_all (optional)
     * @param  bool|null $includei10n (optional)
     * @param  string|null $locale (optional)
     * @param  string|null $modules (optional)
     * @param  bool|null $is_crawler (optional)
     * @param  bool|null $include_notification_count (optional)
     * @param  bool|null $as_tree (optional)
     * @param  int|null $max_tree_depth (optional)
     * @param  bool|null $use_full_translation_ids (optional)
     * @param  string|null $parent_id (optional)
     * @param  string|null $search_text (optional)
     * @param  string[]|null $hash_tags (optional)
     * @param  string|null $user_id (optional)
     * @param  string|null $custom_config_str (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCommentsPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCommentsPublicRequest($tenant_id, $url_id, $page = null, $direction = null, $sso = null, $skip = null, $skip_children = null, $limit = null, $limit_children = null, $count_children = null, $last_gen_date = null, $fetch_page_for_comment_id = null, $include_config = null, $count_all = null, $includei10n = null, $locale = null, $modules = null, $is_crawler = null, $include_notification_count = null, $as_tree = null, $max_tree_depth = null, $use_full_translation_ids = null, $parent_id = null, $search_text = null, $hash_tags = null, $user_id = null, $custom_config_str = null, string $contentType = self::contentTypes['getCommentsPublic'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getCommentsPublic'
            );
        }

        // verify the required parameter 'url_id' is set
        if ($url_id === null || (is_array($url_id) && count($url_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url_id when calling getCommentsPublic'
            );
        }



























        $resourcePath = '/comments/{tenantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_id,
            'urlId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'SortDirections', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip_children,
            'skipChildren', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_children,
            'limitChildren', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count_children,
            'countChildren', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_gen_date,
            'lastGenDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fetch_page_for_comment_id,
            'fetchPageForCommentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_config,
            'includeConfig', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count_all,
            'countAll', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includei10n,
            'includei10n', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $locale,
            'locale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modules,
            'modules', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_crawler,
            'isCrawler', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_notification_count,
            'includeNotificationCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_tree,
            'asTree', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_tree_depth,
            'maxTreeDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_full_translation_ids,
            'useFullTranslationIds', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_text,
            'searchText', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash_tags,
            'hashTags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_config_str,
            'customConfigStr', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEventLog
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $url_id url_id (required)
     * @param  string $user_id_ws user_id_ws (required)
     * @param  int $start_time start_time (required)
     * @param  int $end_time end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventLog'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetEventLog200Response
     */
    public function getEventLog($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getEventLog'][0])
    {
        list($response) = $this->getEventLogWithHttpInfo($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, $contentType);
        return $response;
    }

    /**
     * Operation getEventLogWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $user_id_ws (required)
     * @param  int $start_time (required)
     * @param  int $end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventLog'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetEventLog200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEventLogWithHttpInfo($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getEventLog'][0])
    {
        $request = $this->getEventLogRequest($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetEventLog200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetEventLog200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetEventLog200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetEventLog200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetEventLog200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEventLogAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $user_id_ws (required)
     * @param  int $start_time (required)
     * @param  int $end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventLogAsync($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getEventLog'][0])
    {
        return $this->getEventLogAsyncWithHttpInfo($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEventLogAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $user_id_ws (required)
     * @param  int $start_time (required)
     * @param  int $end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventLogAsyncWithHttpInfo($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getEventLog'][0])
    {
        $returnType = '\FastComments\Client\Model\GetEventLog200Response';
        $request = $this->getEventLogRequest($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEventLog'
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $user_id_ws (required)
     * @param  int $start_time (required)
     * @param  int $end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEventLogRequest($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getEventLog'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getEventLog'
            );
        }

        // verify the required parameter 'url_id' is set
        if ($url_id === null || (is_array($url_id) && count($url_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url_id when calling getEventLog'
            );
        }

        // verify the required parameter 'user_id_ws' is set
        if ($user_id_ws === null || (is_array($user_id_ws) && count($user_id_ws) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id_ws when calling getEventLog'
            );
        }

        // verify the required parameter 'start_time' is set
        if ($start_time === null || (is_array($start_time) && count($start_time) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_time when calling getEventLog'
            );
        }

        // verify the required parameter 'end_time' is set
        if ($end_time === null || (is_array($end_time) && count($end_time) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_time when calling getEventLog'
            );
        }


        $resourcePath = '/event-log/{tenantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_id,
            'urlId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_ws,
            'userIdWS', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeedPostsPublic
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  float|null $after_id after_id (optional)
     * @param  float|null $limit limit (optional)
     * @param  string[]|null $tags tags (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFeedPostsPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetFeedPosts200Response
     */
    public function getFeedPostsPublic($tenant_id, $after_id = null, $limit = null, $tags = null, string $contentType = self::contentTypes['getFeedPostsPublic'][0])
    {
        list($response) = $this->getFeedPostsPublicWithHttpInfo($tenant_id, $after_id, $limit, $tags, $contentType);
        return $response;
    }

    /**
     * Operation getFeedPostsPublicWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  float|null $after_id (optional)
     * @param  float|null $limit (optional)
     * @param  string[]|null $tags (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFeedPostsPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetFeedPosts200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeedPostsPublicWithHttpInfo($tenant_id, $after_id = null, $limit = null, $tags = null, string $contentType = self::contentTypes['getFeedPostsPublic'][0])
    {
        $request = $this->getFeedPostsPublicRequest($tenant_id, $after_id, $limit, $tags, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetFeedPosts200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetFeedPosts200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetFeedPosts200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetFeedPosts200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetFeedPosts200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeedPostsPublicAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  float|null $after_id (optional)
     * @param  float|null $limit (optional)
     * @param  string[]|null $tags (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFeedPostsPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeedPostsPublicAsync($tenant_id, $after_id = null, $limit = null, $tags = null, string $contentType = self::contentTypes['getFeedPostsPublic'][0])
    {
        return $this->getFeedPostsPublicAsyncWithHttpInfo($tenant_id, $after_id, $limit, $tags, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeedPostsPublicAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  float|null $after_id (optional)
     * @param  float|null $limit (optional)
     * @param  string[]|null $tags (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFeedPostsPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeedPostsPublicAsyncWithHttpInfo($tenant_id, $after_id = null, $limit = null, $tags = null, string $contentType = self::contentTypes['getFeedPostsPublic'][0])
    {
        $returnType = '\FastComments\Client\Model\GetFeedPosts200Response';
        $request = $this->getFeedPostsPublicRequest($tenant_id, $after_id, $limit, $tags, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeedPostsPublic'
     *
     * @param  string $tenant_id (required)
     * @param  float|null $after_id (optional)
     * @param  float|null $limit (optional)
     * @param  string[]|null $tags (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFeedPostsPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFeedPostsPublicRequest($tenant_id, $after_id = null, $limit = null, $tags = null, string $contentType = self::contentTypes['getFeedPostsPublic'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getFeedPostsPublic'
            );
        }





        $resourcePath = '/feed-posts/{tenantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after_id,
            'afterId', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGlobalEventLog
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $url_id url_id (required)
     * @param  string $user_id_ws user_id_ws (required)
     * @param  int $start_time start_time (required)
     * @param  int $end_time end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGlobalEventLog'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetEventLog200Response
     */
    public function getGlobalEventLog($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getGlobalEventLog'][0])
    {
        list($response) = $this->getGlobalEventLogWithHttpInfo($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, $contentType);
        return $response;
    }

    /**
     * Operation getGlobalEventLogWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $user_id_ws (required)
     * @param  int $start_time (required)
     * @param  int $end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGlobalEventLog'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetEventLog200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGlobalEventLogWithHttpInfo($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getGlobalEventLog'][0])
    {
        $request = $this->getGlobalEventLogRequest($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetEventLog200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetEventLog200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetEventLog200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetEventLog200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetEventLog200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGlobalEventLogAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $user_id_ws (required)
     * @param  int $start_time (required)
     * @param  int $end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGlobalEventLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGlobalEventLogAsync($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getGlobalEventLog'][0])
    {
        return $this->getGlobalEventLogAsyncWithHttpInfo($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGlobalEventLogAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $user_id_ws (required)
     * @param  int $start_time (required)
     * @param  int $end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGlobalEventLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGlobalEventLogAsyncWithHttpInfo($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getGlobalEventLog'][0])
    {
        $returnType = '\FastComments\Client\Model\GetEventLog200Response';
        $request = $this->getGlobalEventLogRequest($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGlobalEventLog'
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $user_id_ws (required)
     * @param  int $start_time (required)
     * @param  int $end_time (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGlobalEventLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGlobalEventLogRequest($tenant_id, $url_id, $user_id_ws, $start_time, $end_time, string $contentType = self::contentTypes['getGlobalEventLog'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getGlobalEventLog'
            );
        }

        // verify the required parameter 'url_id' is set
        if ($url_id === null || (is_array($url_id) && count($url_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url_id when calling getGlobalEventLog'
            );
        }

        // verify the required parameter 'user_id_ws' is set
        if ($user_id_ws === null || (is_array($user_id_ws) && count($user_id_ws) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id_ws when calling getGlobalEventLog'
            );
        }

        // verify the required parameter 'start_time' is set
        if ($start_time === null || (is_array($start_time) && count($start_time) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_time when calling getGlobalEventLog'
            );
        }

        // verify the required parameter 'end_time' is set
        if ($end_time === null || (is_array($end_time) && count($end_time) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_time when calling getGlobalEventLog'
            );
        }


        $resourcePath = '/event-log/global/{tenantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_id,
            'urlId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_ws,
            'userIdWS', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserNotificationCount
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetUserNotificationCount200Response
     */
    public function getUserNotificationCount($tenant_id, $sso = null, string $contentType = self::contentTypes['getUserNotificationCount'][0])
    {
        list($response) = $this->getUserNotificationCountWithHttpInfo($tenant_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation getUserNotificationCountWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetUserNotificationCount200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserNotificationCountWithHttpInfo($tenant_id, $sso = null, string $contentType = self::contentTypes['getUserNotificationCount'][0])
    {
        $request = $this->getUserNotificationCountRequest($tenant_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetUserNotificationCount200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetUserNotificationCount200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetUserNotificationCount200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetUserNotificationCount200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetUserNotificationCount200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserNotificationCountAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserNotificationCountAsync($tenant_id, $sso = null, string $contentType = self::contentTypes['getUserNotificationCount'][0])
    {
        return $this->getUserNotificationCountAsyncWithHttpInfo($tenant_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserNotificationCountAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserNotificationCountAsyncWithHttpInfo($tenant_id, $sso = null, string $contentType = self::contentTypes['getUserNotificationCount'][0])
    {
        $returnType = '\FastComments\Client\Model\GetUserNotificationCount200Response';
        $request = $this->getUserNotificationCountRequest($tenant_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserNotificationCount'
     *
     * @param  string $tenant_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserNotificationCountRequest($tenant_id, $sso = null, string $contentType = self::contentTypes['getUserNotificationCount'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getUserNotificationCount'
            );
        }



        $resourcePath = '/user-notifications/get-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserNotifications
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  float|null $page_size Defaults to 20. (optional)
     * @param  string|null $after_id after_id (optional)
     * @param  bool|null $include_context include_context (optional)
     * @param  float|null $after_created_at after_created_at (optional)
     * @param  bool|null $unread_only unread_only (optional)
     * @param  bool|null $dm_only dm_only (optional)
     * @param  bool|null $no_dm no_dm (optional)
     * @param  bool|null $include_translations include_translations (optional)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotifications'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetUserNotifications200Response
     */
    public function getUserNotifications($tenant_id, $page_size = null, $after_id = null, $include_context = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $include_translations = null, $sso = null, string $contentType = self::contentTypes['getUserNotifications'][0])
    {
        list($response) = $this->getUserNotificationsWithHttpInfo($tenant_id, $page_size, $after_id, $include_context, $after_created_at, $unread_only, $dm_only, $no_dm, $include_translations, $sso, $contentType);
        return $response;
    }

    /**
     * Operation getUserNotificationsWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  float|null $page_size Defaults to 20. (optional)
     * @param  string|null $after_id (optional)
     * @param  bool|null $include_context (optional)
     * @param  float|null $after_created_at (optional)
     * @param  bool|null $unread_only (optional)
     * @param  bool|null $dm_only (optional)
     * @param  bool|null $no_dm (optional)
     * @param  bool|null $include_translations (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotifications'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetUserNotifications200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserNotificationsWithHttpInfo($tenant_id, $page_size = null, $after_id = null, $include_context = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $include_translations = null, $sso = null, string $contentType = self::contentTypes['getUserNotifications'][0])
    {
        $request = $this->getUserNotificationsRequest($tenant_id, $page_size, $after_id, $include_context, $after_created_at, $unread_only, $dm_only, $no_dm, $include_translations, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetUserNotifications200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetUserNotifications200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetUserNotifications200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetUserNotifications200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetUserNotifications200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserNotificationsAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  float|null $page_size Defaults to 20. (optional)
     * @param  string|null $after_id (optional)
     * @param  bool|null $include_context (optional)
     * @param  float|null $after_created_at (optional)
     * @param  bool|null $unread_only (optional)
     * @param  bool|null $dm_only (optional)
     * @param  bool|null $no_dm (optional)
     * @param  bool|null $include_translations (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserNotificationsAsync($tenant_id, $page_size = null, $after_id = null, $include_context = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $include_translations = null, $sso = null, string $contentType = self::contentTypes['getUserNotifications'][0])
    {
        return $this->getUserNotificationsAsyncWithHttpInfo($tenant_id, $page_size, $after_id, $include_context, $after_created_at, $unread_only, $dm_only, $no_dm, $include_translations, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserNotificationsAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  float|null $page_size Defaults to 20. (optional)
     * @param  string|null $after_id (optional)
     * @param  bool|null $include_context (optional)
     * @param  float|null $after_created_at (optional)
     * @param  bool|null $unread_only (optional)
     * @param  bool|null $dm_only (optional)
     * @param  bool|null $no_dm (optional)
     * @param  bool|null $include_translations (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserNotificationsAsyncWithHttpInfo($tenant_id, $page_size = null, $after_id = null, $include_context = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $include_translations = null, $sso = null, string $contentType = self::contentTypes['getUserNotifications'][0])
    {
        $returnType = '\FastComments\Client\Model\GetUserNotifications200Response';
        $request = $this->getUserNotificationsRequest($tenant_id, $page_size, $after_id, $include_context, $after_created_at, $unread_only, $dm_only, $no_dm, $include_translations, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserNotifications'
     *
     * @param  string $tenant_id (required)
     * @param  float|null $page_size Defaults to 20. (optional)
     * @param  string|null $after_id (optional)
     * @param  bool|null $include_context (optional)
     * @param  float|null $after_created_at (optional)
     * @param  bool|null $unread_only (optional)
     * @param  bool|null $dm_only (optional)
     * @param  bool|null $no_dm (optional)
     * @param  bool|null $include_translations (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserNotificationsRequest($tenant_id, $page_size = null, $after_id = null, $include_context = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $include_translations = null, $sso = null, string $contentType = self::contentTypes['getUserNotifications'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getUserNotifications'
            );
        }











        $resourcePath = '/user-notifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after_id,
            'afterId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_context,
            'includeContext', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after_created_at,
            'afterCreatedAt', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unread_only,
            'unreadOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dm_only,
            'dmOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $no_dm,
            'noDm', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_translations,
            'includeTranslations', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserPresenceStatuses
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $url_id_ws url_id_ws (required)
     * @param  string $user_ids user_ids (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPresenceStatuses'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\GetUserPresenceStatuses200Response|\FastComments\Client\Model\APIError
     */
    public function getUserPresenceStatuses($tenant_id, $url_id_ws, $user_ids, string $contentType = self::contentTypes['getUserPresenceStatuses'][0])
    {
        list($response) = $this->getUserPresenceStatusesWithHttpInfo($tenant_id, $url_id_ws, $user_ids, $contentType);
        return $response;
    }

    /**
     * Operation getUserPresenceStatusesWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id_ws (required)
     * @param  string $user_ids (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPresenceStatuses'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\GetUserPresenceStatuses200Response|\FastComments\Client\Model\APIError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserPresenceStatusesWithHttpInfo($tenant_id, $url_id_ws, $user_ids, string $contentType = self::contentTypes['getUserPresenceStatuses'][0])
    {
        $request = $this->getUserPresenceStatusesRequest($tenant_id, $url_id_ws, $user_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\GetUserPresenceStatuses200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\GetUserPresenceStatuses200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\GetUserPresenceStatuses200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\FastComments\Client\Model\APIError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\APIError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\APIError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\GetUserPresenceStatuses200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\GetUserPresenceStatuses200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\APIError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserPresenceStatusesAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id_ws (required)
     * @param  string $user_ids (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPresenceStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserPresenceStatusesAsync($tenant_id, $url_id_ws, $user_ids, string $contentType = self::contentTypes['getUserPresenceStatuses'][0])
    {
        return $this->getUserPresenceStatusesAsyncWithHttpInfo($tenant_id, $url_id_ws, $user_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserPresenceStatusesAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id_ws (required)
     * @param  string $user_ids (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPresenceStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserPresenceStatusesAsyncWithHttpInfo($tenant_id, $url_id_ws, $user_ids, string $contentType = self::contentTypes['getUserPresenceStatuses'][0])
    {
        $returnType = '\FastComments\Client\Model\GetUserPresenceStatuses200Response';
        $request = $this->getUserPresenceStatusesRequest($tenant_id, $url_id_ws, $user_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserPresenceStatuses'
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id_ws (required)
     * @param  string $user_ids (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPresenceStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserPresenceStatusesRequest($tenant_id, $url_id_ws, $user_ids, string $contentType = self::contentTypes['getUserPresenceStatuses'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getUserPresenceStatuses'
            );
        }

        // verify the required parameter 'url_id_ws' is set
        if ($url_id_ws === null || (is_array($url_id_ws) && count($url_id_ws) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url_id_ws when calling getUserPresenceStatuses'
            );
        }

        // verify the required parameter 'user_ids' is set
        if ($user_ids === null || (is_array($user_ids) && count($user_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_ids when calling getUserPresenceStatuses'
            );
        }


        $resourcePath = '/user-presence-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_id_ws,
            'urlIdWS', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_ids,
            'userIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockComment
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\LockComment200Response
     */
    public function lockComment($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['lockComment'][0])
    {
        list($response) = $this->lockCommentWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation lockCommentWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\LockComment200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockCommentWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['lockComment'][0])
    {
        $request = $this->lockCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\LockComment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\LockComment200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\LockComment200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\LockComment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\LockComment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lockCommentAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockCommentAsync($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['lockComment'][0])
    {
        return $this->lockCommentAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockCommentAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockCommentAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['lockComment'][0])
    {
        $returnType = '\FastComments\Client\Model\LockComment200Response';
        $request = $this->lockCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockComment'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['lockComment'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling lockComment'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling lockComment'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling lockComment'
            );
        }



        $resourcePath = '/comments/{tenantId}/{commentId}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pinComment
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\PinComment200Response
     */
    public function pinComment($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['pinComment'][0])
    {
        list($response) = $this->pinCommentWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation pinCommentWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\PinComment200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function pinCommentWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['pinComment'][0])
    {
        $request = $this->pinCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\PinComment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\PinComment200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\PinComment200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\PinComment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\PinComment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pinCommentAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinCommentAsync($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['pinComment'][0])
    {
        return $this->pinCommentAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pinCommentAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinCommentAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['pinComment'][0])
    {
        $returnType = '\FastComments\Client\Model\PinComment200Response';
        $request = $this->pinCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pinComment'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pinCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['pinComment'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling pinComment'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling pinComment'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling pinComment'
            );
        }



        $resourcePath = '/comments/{tenantId}/{commentId}/pin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetUserNotificationCount
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\ResetUserNotifications200Response
     */
    public function resetUserNotificationCount($tenant_id, $sso = null, string $contentType = self::contentTypes['resetUserNotificationCount'][0])
    {
        list($response) = $this->resetUserNotificationCountWithHttpInfo($tenant_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation resetUserNotificationCountWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\ResetUserNotifications200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetUserNotificationCountWithHttpInfo($tenant_id, $sso = null, string $contentType = self::contentTypes['resetUserNotificationCount'][0])
    {
        $request = $this->resetUserNotificationCountRequest($tenant_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\ResetUserNotifications200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\ResetUserNotifications200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\ResetUserNotifications200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\ResetUserNotifications200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\ResetUserNotifications200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resetUserNotificationCountAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetUserNotificationCountAsync($tenant_id, $sso = null, string $contentType = self::contentTypes['resetUserNotificationCount'][0])
    {
        return $this->resetUserNotificationCountAsyncWithHttpInfo($tenant_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetUserNotificationCountAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetUserNotificationCountAsyncWithHttpInfo($tenant_id, $sso = null, string $contentType = self::contentTypes['resetUserNotificationCount'][0])
    {
        $returnType = '\FastComments\Client\Model\ResetUserNotifications200Response';
        $request = $this->resetUserNotificationCountRequest($tenant_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetUserNotificationCount'
     *
     * @param  string $tenant_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotificationCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resetUserNotificationCountRequest($tenant_id, $sso = null, string $contentType = self::contentTypes['resetUserNotificationCount'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling resetUserNotificationCount'
            );
        }



        $resourcePath = '/user-notifications/reset-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetUserNotifications
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string|null $after_id after_id (optional)
     * @param  float|null $after_created_at after_created_at (optional)
     * @param  bool|null $unread_only unread_only (optional)
     * @param  bool|null $dm_only dm_only (optional)
     * @param  bool|null $no_dm no_dm (optional)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotifications'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\ResetUserNotifications200Response
     */
    public function resetUserNotifications($tenant_id, $after_id = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $sso = null, string $contentType = self::contentTypes['resetUserNotifications'][0])
    {
        list($response) = $this->resetUserNotificationsWithHttpInfo($tenant_id, $after_id, $after_created_at, $unread_only, $dm_only, $no_dm, $sso, $contentType);
        return $response;
    }

    /**
     * Operation resetUserNotificationsWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $after_id (optional)
     * @param  float|null $after_created_at (optional)
     * @param  bool|null $unread_only (optional)
     * @param  bool|null $dm_only (optional)
     * @param  bool|null $no_dm (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotifications'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\ResetUserNotifications200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetUserNotificationsWithHttpInfo($tenant_id, $after_id = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $sso = null, string $contentType = self::contentTypes['resetUserNotifications'][0])
    {
        $request = $this->resetUserNotificationsRequest($tenant_id, $after_id, $after_created_at, $unread_only, $dm_only, $no_dm, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\ResetUserNotifications200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\ResetUserNotifications200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\ResetUserNotifications200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\ResetUserNotifications200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\ResetUserNotifications200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resetUserNotificationsAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $after_id (optional)
     * @param  float|null $after_created_at (optional)
     * @param  bool|null $unread_only (optional)
     * @param  bool|null $dm_only (optional)
     * @param  bool|null $no_dm (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetUserNotificationsAsync($tenant_id, $after_id = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $sso = null, string $contentType = self::contentTypes['resetUserNotifications'][0])
    {
        return $this->resetUserNotificationsAsyncWithHttpInfo($tenant_id, $after_id, $after_created_at, $unread_only, $dm_only, $no_dm, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetUserNotificationsAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string|null $after_id (optional)
     * @param  float|null $after_created_at (optional)
     * @param  bool|null $unread_only (optional)
     * @param  bool|null $dm_only (optional)
     * @param  bool|null $no_dm (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetUserNotificationsAsyncWithHttpInfo($tenant_id, $after_id = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $sso = null, string $contentType = self::contentTypes['resetUserNotifications'][0])
    {
        $returnType = '\FastComments\Client\Model\ResetUserNotifications200Response';
        $request = $this->resetUserNotificationsRequest($tenant_id, $after_id, $after_created_at, $unread_only, $dm_only, $no_dm, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetUserNotifications'
     *
     * @param  string $tenant_id (required)
     * @param  string|null $after_id (optional)
     * @param  float|null $after_created_at (optional)
     * @param  bool|null $unread_only (optional)
     * @param  bool|null $dm_only (optional)
     * @param  bool|null $no_dm (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetUserNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resetUserNotificationsRequest($tenant_id, $after_id = null, $after_created_at = null, $unread_only = null, $dm_only = null, $no_dm = null, $sso = null, string $contentType = self::contentTypes['resetUserNotifications'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling resetUserNotifications'
            );
        }








        $resourcePath = '/user-notifications/reset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after_id,
            'afterId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after_created_at,
            'afterCreatedAt', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unread_only,
            'unreadOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dm_only,
            'dmOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $no_dm,
            'noDm', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCommentText
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentTextUpdateRequest $comment_text_update_request comment_text_update_request (required)
     * @param  string|null $edit_key edit_key (optional)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCommentText'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\SetCommentText200Response
     */
    public function setCommentText($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key = null, $sso = null, string $contentType = self::contentTypes['setCommentText'][0])
    {
        list($response) = $this->setCommentTextWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key, $sso, $contentType);
        return $response;
    }

    /**
     * Operation setCommentTextWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentTextUpdateRequest $comment_text_update_request (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCommentText'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\SetCommentText200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCommentTextWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key = null, $sso = null, string $contentType = self::contentTypes['setCommentText'][0])
    {
        $request = $this->setCommentTextRequest($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\SetCommentText200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\SetCommentText200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\SetCommentText200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\SetCommentText200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\SetCommentText200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCommentTextAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentTextUpdateRequest $comment_text_update_request (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCommentText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCommentTextAsync($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key = null, $sso = null, string $contentType = self::contentTypes['setCommentText'][0])
    {
        return $this->setCommentTextAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCommentTextAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentTextUpdateRequest $comment_text_update_request (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCommentText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCommentTextAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key = null, $sso = null, string $contentType = self::contentTypes['setCommentText'][0])
    {
        $returnType = '\FastComments\Client\Model\SetCommentText200Response';
        $request = $this->setCommentTextRequest($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCommentText'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\CommentTextUpdateRequest $comment_text_update_request (required)
     * @param  string|null $edit_key (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCommentText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setCommentTextRequest($tenant_id, $comment_id, $broadcast_id, $comment_text_update_request, $edit_key = null, $sso = null, string $contentType = self::contentTypes['setCommentText'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling setCommentText'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling setCommentText'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling setCommentText'
            );
        }

        // verify the required parameter 'comment_text_update_request' is set
        if ($comment_text_update_request === null || (is_array($comment_text_update_request) && count($comment_text_update_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_text_update_request when calling setCommentText'
            );
        }




        $resourcePath = '/comments/{tenantId}/{commentId}/update-text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $edit_key,
            'editKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($comment_text_update_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($comment_text_update_request));
            } else {
                $httpBody = $comment_text_update_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unBlockCommentPublic
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params public_block_from_comment_params (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unBlockCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\UnBlockCommentPublic200Response
     */
    public function unBlockCommentPublic($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['unBlockCommentPublic'][0])
    {
        list($response) = $this->unBlockCommentPublicWithHttpInfo($tenant_id, $comment_id, $public_block_from_comment_params, $sso, $contentType);
        return $response;
    }

    /**
     * Operation unBlockCommentPublicWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unBlockCommentPublic'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\UnBlockCommentPublic200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function unBlockCommentPublicWithHttpInfo($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['unBlockCommentPublic'][0])
    {
        $request = $this->unBlockCommentPublicRequest($tenant_id, $comment_id, $public_block_from_comment_params, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\UnBlockCommentPublic200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\UnBlockCommentPublic200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\UnBlockCommentPublic200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\UnBlockCommentPublic200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\UnBlockCommentPublic200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unBlockCommentPublicAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unBlockCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unBlockCommentPublicAsync($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['unBlockCommentPublic'][0])
    {
        return $this->unBlockCommentPublicAsyncWithHttpInfo($tenant_id, $comment_id, $public_block_from_comment_params, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unBlockCommentPublicAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unBlockCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unBlockCommentPublicAsyncWithHttpInfo($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['unBlockCommentPublic'][0])
    {
        $returnType = '\FastComments\Client\Model\UnBlockCommentPublic200Response';
        $request = $this->unBlockCommentPublicRequest($tenant_id, $comment_id, $public_block_from_comment_params, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unBlockCommentPublic'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  \FastComments\Client\Model\PublicBlockFromCommentParams $public_block_from_comment_params (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unBlockCommentPublic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unBlockCommentPublicRequest($tenant_id, $comment_id, $public_block_from_comment_params, $sso = null, string $contentType = self::contentTypes['unBlockCommentPublic'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling unBlockCommentPublic'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling unBlockCommentPublic'
            );
        }

        // verify the required parameter 'public_block_from_comment_params' is set
        if ($public_block_from_comment_params === null || (is_array($public_block_from_comment_params) && count($public_block_from_comment_params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $public_block_from_comment_params when calling unBlockCommentPublic'
            );
        }



        $resourcePath = '/block-from-comment/{commentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_block_from_comment_params)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_block_from_comment_params));
            } else {
                $httpBody = $public_block_from_comment_params;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unLockComment
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unLockComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\LockComment200Response
     */
    public function unLockComment($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unLockComment'][0])
    {
        list($response) = $this->unLockCommentWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation unLockCommentWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unLockComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\LockComment200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function unLockCommentWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unLockComment'][0])
    {
        $request = $this->unLockCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\LockComment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\LockComment200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\LockComment200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\LockComment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\LockComment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unLockCommentAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unLockComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unLockCommentAsync($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unLockComment'][0])
    {
        return $this->unLockCommentAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unLockCommentAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unLockComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unLockCommentAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unLockComment'][0])
    {
        $returnType = '\FastComments\Client\Model\LockComment200Response';
        $request = $this->unLockCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unLockComment'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unLockComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unLockCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unLockComment'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling unLockComment'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling unLockComment'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling unLockComment'
            );
        }



        $resourcePath = '/comments/{tenantId}/{commentId}/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unPinComment
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unPinComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\PinComment200Response
     */
    public function unPinComment($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unPinComment'][0])
    {
        list($response) = $this->unPinCommentWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation unPinCommentWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unPinComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\PinComment200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function unPinCommentWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unPinComment'][0])
    {
        $request = $this->unPinCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\PinComment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\PinComment200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\PinComment200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\PinComment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\PinComment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unPinCommentAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unPinComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unPinCommentAsync($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unPinComment'][0])
    {
        return $this->unPinCommentAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unPinCommentAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unPinComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unPinCommentAsyncWithHttpInfo($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unPinComment'][0])
    {
        $returnType = '\FastComments\Client\Model\PinComment200Response';
        $request = $this->unPinCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unPinComment'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $broadcast_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unPinComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unPinCommentRequest($tenant_id, $comment_id, $broadcast_id, $sso = null, string $contentType = self::contentTypes['unPinComment'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling unPinComment'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling unPinComment'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling unPinComment'
            );
        }



        $resourcePath = '/comments/{tenantId}/{commentId}/unpin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUserNotificationCommentSubscriptionStatus
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $notification_id notification_id (required)
     * @param  string $opted_in_or_out opted_in_or_out (required)
     * @param  string $comment_id comment_id (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationCommentSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\UpdateUserNotificationStatus200Response
     */
    public function updateUserNotificationCommentSubscriptionStatus($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso = null, string $contentType = self::contentTypes['updateUserNotificationCommentSubscriptionStatus'][0])
    {
        list($response) = $this->updateUserNotificationCommentSubscriptionStatusWithHttpInfo($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation updateUserNotificationCommentSubscriptionStatusWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $notification_id (required)
     * @param  string $opted_in_or_out (required)
     * @param  string $comment_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationCommentSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\UpdateUserNotificationStatus200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserNotificationCommentSubscriptionStatusWithHttpInfo($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso = null, string $contentType = self::contentTypes['updateUserNotificationCommentSubscriptionStatus'][0])
    {
        $request = $this->updateUserNotificationCommentSubscriptionStatusRequest($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\UpdateUserNotificationStatus200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\UpdateUserNotificationStatus200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\UpdateUserNotificationStatus200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\UpdateUserNotificationStatus200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\UpdateUserNotificationStatus200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateUserNotificationCommentSubscriptionStatusAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $notification_id (required)
     * @param  string $opted_in_or_out (required)
     * @param  string $comment_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationCommentSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserNotificationCommentSubscriptionStatusAsync($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso = null, string $contentType = self::contentTypes['updateUserNotificationCommentSubscriptionStatus'][0])
    {
        return $this->updateUserNotificationCommentSubscriptionStatusAsyncWithHttpInfo($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserNotificationCommentSubscriptionStatusAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $notification_id (required)
     * @param  string $opted_in_or_out (required)
     * @param  string $comment_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationCommentSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserNotificationCommentSubscriptionStatusAsyncWithHttpInfo($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso = null, string $contentType = self::contentTypes['updateUserNotificationCommentSubscriptionStatus'][0])
    {
        $returnType = '\FastComments\Client\Model\UpdateUserNotificationStatus200Response';
        $request = $this->updateUserNotificationCommentSubscriptionStatusRequest($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUserNotificationCommentSubscriptionStatus'
     *
     * @param  string $tenant_id (required)
     * @param  string $notification_id (required)
     * @param  string $opted_in_or_out (required)
     * @param  string $comment_id (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationCommentSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateUserNotificationCommentSubscriptionStatusRequest($tenant_id, $notification_id, $opted_in_or_out, $comment_id, $sso = null, string $contentType = self::contentTypes['updateUserNotificationCommentSubscriptionStatus'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling updateUserNotificationCommentSubscriptionStatus'
            );
        }

        // verify the required parameter 'notification_id' is set
        if ($notification_id === null || (is_array($notification_id) && count($notification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $notification_id when calling updateUserNotificationCommentSubscriptionStatus'
            );
        }

        // verify the required parameter 'opted_in_or_out' is set
        if ($opted_in_or_out === null || (is_array($opted_in_or_out) && count($opted_in_or_out) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $opted_in_or_out when calling updateUserNotificationCommentSubscriptionStatus'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling updateUserNotificationCommentSubscriptionStatus'
            );
        }



        $resourcePath = '/user-notifications/{notificationId}/mark-opted/{optedInOrOut}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment_id,
            'commentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($notification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'notificationId' . '}',
                ObjectSerializer::toPathValue($notification_id),
                $resourcePath
            );
        }
        // path params
        if ($opted_in_or_out !== null) {
            $resourcePath = str_replace(
                '{' . 'optedInOrOut' . '}',
                ObjectSerializer::toPathValue($opted_in_or_out),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUserNotificationPageSubscriptionStatus
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $url_id url_id (required)
     * @param  string $url url (required)
     * @param  string $page_title page_title (required)
     * @param  string $subscribed_or_unsubscribed subscribed_or_unsubscribed (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationPageSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\UpdateUserNotificationStatus200Response
     */
    public function updateUserNotificationPageSubscriptionStatus($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso = null, string $contentType = self::contentTypes['updateUserNotificationPageSubscriptionStatus'][0])
    {
        list($response) = $this->updateUserNotificationPageSubscriptionStatusWithHttpInfo($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso, $contentType);
        return $response;
    }

    /**
     * Operation updateUserNotificationPageSubscriptionStatusWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $url (required)
     * @param  string $page_title (required)
     * @param  string $subscribed_or_unsubscribed (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationPageSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\UpdateUserNotificationStatus200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserNotificationPageSubscriptionStatusWithHttpInfo($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso = null, string $contentType = self::contentTypes['updateUserNotificationPageSubscriptionStatus'][0])
    {
        $request = $this->updateUserNotificationPageSubscriptionStatusRequest($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\UpdateUserNotificationStatus200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\UpdateUserNotificationStatus200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\UpdateUserNotificationStatus200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\UpdateUserNotificationStatus200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\UpdateUserNotificationStatus200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateUserNotificationPageSubscriptionStatusAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $url (required)
     * @param  string $page_title (required)
     * @param  string $subscribed_or_unsubscribed (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationPageSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserNotificationPageSubscriptionStatusAsync($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso = null, string $contentType = self::contentTypes['updateUserNotificationPageSubscriptionStatus'][0])
    {
        return $this->updateUserNotificationPageSubscriptionStatusAsyncWithHttpInfo($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserNotificationPageSubscriptionStatusAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $url (required)
     * @param  string $page_title (required)
     * @param  string $subscribed_or_unsubscribed (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationPageSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserNotificationPageSubscriptionStatusAsyncWithHttpInfo($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso = null, string $contentType = self::contentTypes['updateUserNotificationPageSubscriptionStatus'][0])
    {
        $returnType = '\FastComments\Client\Model\UpdateUserNotificationStatus200Response';
        $request = $this->updateUserNotificationPageSubscriptionStatusRequest($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUserNotificationPageSubscriptionStatus'
     *
     * @param  string $tenant_id (required)
     * @param  string $url_id (required)
     * @param  string $url (required)
     * @param  string $page_title (required)
     * @param  string $subscribed_or_unsubscribed (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationPageSubscriptionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateUserNotificationPageSubscriptionStatusRequest($tenant_id, $url_id, $url, $page_title, $subscribed_or_unsubscribed, $sso = null, string $contentType = self::contentTypes['updateUserNotificationPageSubscriptionStatus'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling updateUserNotificationPageSubscriptionStatus'
            );
        }

        // verify the required parameter 'url_id' is set
        if ($url_id === null || (is_array($url_id) && count($url_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url_id when calling updateUserNotificationPageSubscriptionStatus'
            );
        }

        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling updateUserNotificationPageSubscriptionStatus'
            );
        }

        // verify the required parameter 'page_title' is set
        if ($page_title === null || (is_array($page_title) && count($page_title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_title when calling updateUserNotificationPageSubscriptionStatus'
            );
        }

        // verify the required parameter 'subscribed_or_unsubscribed' is set
        if ($subscribed_or_unsubscribed === null || (is_array($subscribed_or_unsubscribed) && count($subscribed_or_unsubscribed) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscribed_or_unsubscribed when calling updateUserNotificationPageSubscriptionStatus'
            );
        }



        $resourcePath = '/user-notifications/set-subscription-state/{subscribedOrUnsubscribed}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_id,
            'urlId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_title,
            'pageTitle', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($subscribed_or_unsubscribed !== null) {
            $resourcePath = str_replace(
                '{' . 'subscribedOrUnsubscribed' . '}',
                ObjectSerializer::toPathValue($subscribed_or_unsubscribed),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUserNotificationStatus
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $notification_id notification_id (required)
     * @param  string $new_status new_status (required)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationStatus'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\UpdateUserNotificationStatus200Response
     */
    public function updateUserNotificationStatus($tenant_id, $notification_id, $new_status, $sso = null, string $contentType = self::contentTypes['updateUserNotificationStatus'][0])
    {
        list($response) = $this->updateUserNotificationStatusWithHttpInfo($tenant_id, $notification_id, $new_status, $sso, $contentType);
        return $response;
    }

    /**
     * Operation updateUserNotificationStatusWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $notification_id (required)
     * @param  string $new_status (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationStatus'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\UpdateUserNotificationStatus200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserNotificationStatusWithHttpInfo($tenant_id, $notification_id, $new_status, $sso = null, string $contentType = self::contentTypes['updateUserNotificationStatus'][0])
    {
        $request = $this->updateUserNotificationStatusRequest($tenant_id, $notification_id, $new_status, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\UpdateUserNotificationStatus200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\UpdateUserNotificationStatus200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\UpdateUserNotificationStatus200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\UpdateUserNotificationStatus200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\UpdateUserNotificationStatus200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateUserNotificationStatusAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $notification_id (required)
     * @param  string $new_status (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserNotificationStatusAsync($tenant_id, $notification_id, $new_status, $sso = null, string $contentType = self::contentTypes['updateUserNotificationStatus'][0])
    {
        return $this->updateUserNotificationStatusAsyncWithHttpInfo($tenant_id, $notification_id, $new_status, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserNotificationStatusAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $notification_id (required)
     * @param  string $new_status (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserNotificationStatusAsyncWithHttpInfo($tenant_id, $notification_id, $new_status, $sso = null, string $contentType = self::contentTypes['updateUserNotificationStatus'][0])
    {
        $returnType = '\FastComments\Client\Model\UpdateUserNotificationStatus200Response';
        $request = $this->updateUserNotificationStatusRequest($tenant_id, $notification_id, $new_status, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUserNotificationStatus'
     *
     * @param  string $tenant_id (required)
     * @param  string $notification_id (required)
     * @param  string $new_status (required)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserNotificationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateUserNotificationStatusRequest($tenant_id, $notification_id, $new_status, $sso = null, string $contentType = self::contentTypes['updateUserNotificationStatus'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling updateUserNotificationStatus'
            );
        }

        // verify the required parameter 'notification_id' is set
        if ($notification_id === null || (is_array($notification_id) && count($notification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $notification_id when calling updateUserNotificationStatus'
            );
        }

        // verify the required parameter 'new_status' is set
        if ($new_status === null || (is_array($new_status) && count($new_status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_status when calling updateUserNotificationStatus'
            );
        }



        $resourcePath = '/user-notifications/{notificationId}/mark/{newStatus}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($notification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'notificationId' . '}',
                ObjectSerializer::toPathValue($notification_id),
                $resourcePath
            );
        }
        // path params
        if ($new_status !== null) {
            $resourcePath = str_replace(
                '{' . 'newStatus' . '}',
                ObjectSerializer::toPathValue($new_status),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation voteComment
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id tenant_id (required)
     * @param  string $comment_id comment_id (required)
     * @param  string $url_id url_id (required)
     * @param  string $broadcast_id broadcast_id (required)
     * @param  \FastComments\Client\Model\VoteBodyParams $vote_body_params vote_body_params (required)
     * @param  string|null $session_id session_id (optional)
     * @param  string|null $sso sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voteComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FastComments\Client\Model\VoteComment200Response
     */
    public function voteComment($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id = null, $sso = null, string $contentType = self::contentTypes['voteComment'][0])
    {
        list($response) = $this->voteCommentWithHttpInfo($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id, $sso, $contentType);
        return $response;
    }

    /**
     * Operation voteCommentWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\VoteBodyParams $vote_body_params (required)
     * @param  string|null $session_id (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voteComment'] to see the possible values for this operation
     *
     * @throws \FastComments\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FastComments\Client\Model\VoteComment200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function voteCommentWithHttpInfo($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id = null, $sso = null, string $contentType = self::contentTypes['voteComment'][0])
    {
        $request = $this->voteCommentRequest($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id, $sso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\FastComments\Client\Model\VoteComment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FastComments\Client\Model\VoteComment200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FastComments\Client\Model\VoteComment200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FastComments\Client\Model\VoteComment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FastComments\Client\Model\VoteComment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voteCommentAsync
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\VoteBodyParams $vote_body_params (required)
     * @param  string|null $session_id (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voteComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voteCommentAsync($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id = null, $sso = null, string $contentType = self::contentTypes['voteComment'][0])
    {
        return $this->voteCommentAsyncWithHttpInfo($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id, $sso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation voteCommentAsyncWithHttpInfo
     *
     * FastComments PHP API Client - A SDK for interacting with the FastComments API
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\VoteBodyParams $vote_body_params (required)
     * @param  string|null $session_id (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voteComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voteCommentAsyncWithHttpInfo($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id = null, $sso = null, string $contentType = self::contentTypes['voteComment'][0])
    {
        $returnType = '\FastComments\Client\Model\VoteComment200Response';
        $request = $this->voteCommentRequest($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id, $sso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'voteComment'
     *
     * @param  string $tenant_id (required)
     * @param  string $comment_id (required)
     * @param  string $url_id (required)
     * @param  string $broadcast_id (required)
     * @param  \FastComments\Client\Model\VoteBodyParams $vote_body_params (required)
     * @param  string|null $session_id (optional)
     * @param  string|null $sso (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voteComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function voteCommentRequest($tenant_id, $comment_id, $url_id, $broadcast_id, $vote_body_params, $session_id = null, $sso = null, string $contentType = self::contentTypes['voteComment'][0])
    {

        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling voteComment'
            );
        }

        // verify the required parameter 'comment_id' is set
        if ($comment_id === null || (is_array($comment_id) && count($comment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling voteComment'
            );
        }

        // verify the required parameter 'url_id' is set
        if ($url_id === null || (is_array($url_id) && count($url_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url_id when calling voteComment'
            );
        }

        // verify the required parameter 'broadcast_id' is set
        if ($broadcast_id === null || (is_array($broadcast_id) && count($broadcast_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_id when calling voteComment'
            );
        }

        // verify the required parameter 'vote_body_params' is set
        if ($vote_body_params === null || (is_array($vote_body_params) && count($vote_body_params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vote_body_params when calling voteComment'
            );
        }




        $resourcePath = '/comments/{tenantId}/{commentId}/vote';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_id,
            'urlId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $broadcast_id,
            'broadcastId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $session_id,
            'sessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sso,
            'sso', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vote_body_params)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vote_body_params));
            } else {
                $httpBody = $vote_body_params;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
